// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: master.proto

#ifndef PROTOBUF_INCLUDED_master_2eproto
#define PROTOBUF_INCLUDED_master_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "shard.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_master_2eproto 

namespace protobuf_master_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_master_2eproto
namespace elasticfaiss {
class BootstrapRequest;
class BootstrapRequestDefaultTypeInternal;
extern BootstrapRequestDefaultTypeInternal _BootstrapRequest_default_instance_;
class BootstrapResponse;
class BootstrapResponseDefaultTypeInternal;
extern BootstrapResponseDefaultTypeInternal _BootstrapResponse_default_instance_;
class ClusterSettings;
class ClusterSettingsDefaultTypeInternal;
extern ClusterSettingsDefaultTypeInternal _ClusterSettings_default_instance_;
class ClusterState;
class ClusterStateDefaultTypeInternal;
extern ClusterStateDefaultTypeInternal _ClusterState_default_instance_;
class CreateIndexRequest;
class CreateIndexRequestDefaultTypeInternal;
extern CreateIndexRequestDefaultTypeInternal _CreateIndexRequest_default_instance_;
class CreateIndexResponse;
class CreateIndexResponseDefaultTypeInternal;
extern CreateIndexResponseDefaultTypeInternal _CreateIndexResponse_default_instance_;
class DeleteIndexRequest;
class DeleteIndexRequestDefaultTypeInternal;
extern DeleteIndexRequestDefaultTypeInternal _DeleteIndexRequest_default_instance_;
class DeleteIndexResponse;
class DeleteIndexResponseDefaultTypeInternal;
extern DeleteIndexResponseDefaultTypeInternal _DeleteIndexResponse_default_instance_;
class GetClusterStateRequest;
class GetClusterStateRequestDefaultTypeInternal;
extern GetClusterStateRequestDefaultTypeInternal _GetClusterStateRequest_default_instance_;
class GetClusterStateResponse;
class GetClusterStateResponseDefaultTypeInternal;
extern GetClusterStateResponseDefaultTypeInternal _GetClusterStateResponse_default_instance_;
class MasterSnapshot;
class MasterSnapshotDefaultTypeInternal;
extern MasterSnapshotDefaultTypeInternal _MasterSnapshot_default_instance_;
class NodeHeartbeatRequest;
class NodeHeartbeatRequestDefaultTypeInternal;
extern NodeHeartbeatRequestDefaultTypeInternal _NodeHeartbeatRequest_default_instance_;
class NodeHeartbeatResponse;
class NodeHeartbeatResponseDefaultTypeInternal;
extern NodeHeartbeatResponseDefaultTypeInternal _NodeHeartbeatResponse_default_instance_;
class UpdateClusterSettingRequest;
class UpdateClusterSettingRequestDefaultTypeInternal;
extern UpdateClusterSettingRequestDefaultTypeInternal _UpdateClusterSettingRequest_default_instance_;
class UpdateClusterSettingResponse;
class UpdateClusterSettingResponseDefaultTypeInternal;
extern UpdateClusterSettingResponseDefaultTypeInternal _UpdateClusterSettingResponse_default_instance_;
class UpdateIndexRequest;
class UpdateIndexRequestDefaultTypeInternal;
extern UpdateIndexRequestDefaultTypeInternal _UpdateIndexRequest_default_instance_;
class UpdateIndexResponse;
class UpdateIndexResponseDefaultTypeInternal;
extern UpdateIndexResponseDefaultTypeInternal _UpdateIndexResponse_default_instance_;
class UpdateNodeRequest;
class UpdateNodeRequestDefaultTypeInternal;
extern UpdateNodeRequestDefaultTypeInternal _UpdateNodeRequest_default_instance_;
class UpdateNodeResponse;
class UpdateNodeResponseDefaultTypeInternal;
extern UpdateNodeResponseDefaultTypeInternal _UpdateNodeResponse_default_instance_;
class WorkNode;
class WorkNodeDefaultTypeInternal;
extern WorkNodeDefaultTypeInternal _WorkNode_default_instance_;
}  // namespace elasticfaiss
namespace google {
namespace protobuf {
template<> ::elasticfaiss::BootstrapRequest* Arena::CreateMaybeMessage<::elasticfaiss::BootstrapRequest>(Arena*);
template<> ::elasticfaiss::BootstrapResponse* Arena::CreateMaybeMessage<::elasticfaiss::BootstrapResponse>(Arena*);
template<> ::elasticfaiss::ClusterSettings* Arena::CreateMaybeMessage<::elasticfaiss::ClusterSettings>(Arena*);
template<> ::elasticfaiss::ClusterState* Arena::CreateMaybeMessage<::elasticfaiss::ClusterState>(Arena*);
template<> ::elasticfaiss::CreateIndexRequest* Arena::CreateMaybeMessage<::elasticfaiss::CreateIndexRequest>(Arena*);
template<> ::elasticfaiss::CreateIndexResponse* Arena::CreateMaybeMessage<::elasticfaiss::CreateIndexResponse>(Arena*);
template<> ::elasticfaiss::DeleteIndexRequest* Arena::CreateMaybeMessage<::elasticfaiss::DeleteIndexRequest>(Arena*);
template<> ::elasticfaiss::DeleteIndexResponse* Arena::CreateMaybeMessage<::elasticfaiss::DeleteIndexResponse>(Arena*);
template<> ::elasticfaiss::GetClusterStateRequest* Arena::CreateMaybeMessage<::elasticfaiss::GetClusterStateRequest>(Arena*);
template<> ::elasticfaiss::GetClusterStateResponse* Arena::CreateMaybeMessage<::elasticfaiss::GetClusterStateResponse>(Arena*);
template<> ::elasticfaiss::MasterSnapshot* Arena::CreateMaybeMessage<::elasticfaiss::MasterSnapshot>(Arena*);
template<> ::elasticfaiss::NodeHeartbeatRequest* Arena::CreateMaybeMessage<::elasticfaiss::NodeHeartbeatRequest>(Arena*);
template<> ::elasticfaiss::NodeHeartbeatResponse* Arena::CreateMaybeMessage<::elasticfaiss::NodeHeartbeatResponse>(Arena*);
template<> ::elasticfaiss::UpdateClusterSettingRequest* Arena::CreateMaybeMessage<::elasticfaiss::UpdateClusterSettingRequest>(Arena*);
template<> ::elasticfaiss::UpdateClusterSettingResponse* Arena::CreateMaybeMessage<::elasticfaiss::UpdateClusterSettingResponse>(Arena*);
template<> ::elasticfaiss::UpdateIndexRequest* Arena::CreateMaybeMessage<::elasticfaiss::UpdateIndexRequest>(Arena*);
template<> ::elasticfaiss::UpdateIndexResponse* Arena::CreateMaybeMessage<::elasticfaiss::UpdateIndexResponse>(Arena*);
template<> ::elasticfaiss::UpdateNodeRequest* Arena::CreateMaybeMessage<::elasticfaiss::UpdateNodeRequest>(Arena*);
template<> ::elasticfaiss::UpdateNodeResponse* Arena::CreateMaybeMessage<::elasticfaiss::UpdateNodeResponse>(Arena*);
template<> ::elasticfaiss::WorkNode* Arena::CreateMaybeMessage<::elasticfaiss::WorkNode>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace elasticfaiss {

enum WorkNodeState {
  WNODE_ACTIVE = 1,
  WNODE_TIMEOUT = 2
};
bool WorkNodeState_IsValid(int value);
const WorkNodeState WorkNodeState_MIN = WNODE_ACTIVE;
const WorkNodeState WorkNodeState_MAX = WNODE_TIMEOUT;
const int WorkNodeState_ARRAYSIZE = WorkNodeState_MAX + 1;

const ::google::protobuf::EnumDescriptor* WorkNodeState_descriptor();
inline const ::std::string& WorkNodeState_Name(WorkNodeState value) {
  return ::google::protobuf::internal::NameOfEnum(
    WorkNodeState_descriptor(), value);
}
inline bool WorkNodeState_Parse(
    const ::std::string& name, WorkNodeState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WorkNodeState>(
    WorkNodeState_descriptor(), name, value);
}
enum NodeRole {
  NODE_DATA = 1,
  NODE_PROXY = 2
};
bool NodeRole_IsValid(int value);
const NodeRole NodeRole_MIN = NODE_DATA;
const NodeRole NodeRole_MAX = NODE_PROXY;
const int NodeRole_ARRAYSIZE = NodeRole_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeRole_descriptor();
inline const ::std::string& NodeRole_Name(NodeRole value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeRole_descriptor(), value);
}
inline bool NodeRole_Parse(
    const ::std::string& name, NodeRole* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeRole>(
    NodeRole_descriptor(), name, value);
}
// ===================================================================

class ClusterSettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.ClusterSettings) */ {
 public:
  ClusterSettings();
  virtual ~ClusterSettings();

  ClusterSettings(const ClusterSettings& from);

  inline ClusterSettings& operator=(const ClusterSettings& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClusterSettings(ClusterSettings&& from) noexcept
    : ClusterSettings() {
    *this = ::std::move(from);
  }

  inline ClusterSettings& operator=(ClusterSettings&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterSettings& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClusterSettings* internal_default_instance() {
    return reinterpret_cast<const ClusterSettings*>(
               &_ClusterSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ClusterSettings* other);
  friend void swap(ClusterSettings& a, ClusterSettings& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClusterSettings* New() const final {
    return CreateMaybeMessage<ClusterSettings>(NULL);
  }

  ClusterSettings* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClusterSettings>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClusterSettings& from);
  void MergeFrom(const ClusterSettings& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClusterSettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 shard_allocation_after_timeout_secs = 1 [default = 60];
  bool has_shard_allocation_after_timeout_secs() const;
  void clear_shard_allocation_after_timeout_secs();
  static const int kShardAllocationAfterTimeoutSecsFieldNumber = 1;
  ::google::protobuf::int32 shard_allocation_after_timeout_secs() const;
  void set_shard_allocation_after_timeout_secs(::google::protobuf::int32 value);

  // optional int32 total_shards_per_node = 2 [default = -1];
  bool has_total_shards_per_node() const;
  void clear_total_shards_per_node();
  static const int kTotalShardsPerNodeFieldNumber = 2;
  ::google::protobuf::int32 total_shards_per_node() const;
  void set_total_shards_per_node(::google::protobuf::int32 value);

  // optional int32 index_rpc_timeout_ms = 3 [default = 10000];
  bool has_index_rpc_timeout_ms() const;
  void clear_index_rpc_timeout_ms();
  static const int kIndexRpcTimeoutMsFieldNumber = 3;
  ::google::protobuf::int32 index_rpc_timeout_ms() const;
  void set_index_rpc_timeout_ms(::google::protobuf::int32 value);

  // optional int32 index_rpc_max_retry = 4 [default = 2];
  bool has_index_rpc_max_retry() const;
  void clear_index_rpc_max_retry();
  static const int kIndexRpcMaxRetryFieldNumber = 4;
  ::google::protobuf::int32 index_rpc_max_retry() const;
  void set_index_rpc_max_retry(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.ClusterSettings)
 private:
  void set_has_shard_allocation_after_timeout_secs();
  void clear_has_shard_allocation_after_timeout_secs();
  void set_has_total_shards_per_node();
  void clear_has_total_shards_per_node();
  void set_has_index_rpc_timeout_ms();
  void clear_has_index_rpc_timeout_ms();
  void set_has_index_rpc_max_retry();
  void clear_has_index_rpc_max_retry();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 shard_allocation_after_timeout_secs_;
  ::google::protobuf::int32 total_shards_per_node_;
  ::google::protobuf::int32 index_rpc_timeout_ms_;
  ::google::protobuf::int32 index_rpc_max_retry_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WorkNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.WorkNode) */ {
 public:
  WorkNode();
  virtual ~WorkNode();

  WorkNode(const WorkNode& from);

  inline WorkNode& operator=(const WorkNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkNode(WorkNode&& from) noexcept
    : WorkNode() {
    *this = ::std::move(from);
  }

  inline WorkNode& operator=(WorkNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkNode* internal_default_instance() {
    return reinterpret_cast<const WorkNode*>(
               &_WorkNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(WorkNode* other);
  friend void swap(WorkNode& a, WorkNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkNode* New() const final {
    return CreateMaybeMessage<WorkNode>(NULL);
  }

  WorkNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkNode& from);
  void MergeFrom(const WorkNode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .elasticfaiss.Shard shards = 4;
  int shards_size() const;
  void clear_shards();
  static const int kShardsFieldNumber = 4;
  ::elasticfaiss::Shard* mutable_shards(int index);
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard >*
      mutable_shards();
  const ::elasticfaiss::Shard& shards(int index) const;
  ::elasticfaiss::Shard* add_shards();
  const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard >&
      shards() const;

  // required string peer_id = 1;
  bool has_peer_id() const;
  void clear_peer_id();
  static const int kPeerIdFieldNumber = 1;
  const ::std::string& peer_id() const;
  void set_peer_id(const ::std::string& value);
  #if LANG_CXX11
  void set_peer_id(::std::string&& value);
  #endif
  void set_peer_id(const char* value);
  void set_peer_id(const char* value, size_t size);
  ::std::string* mutable_peer_id();
  ::std::string* release_peer_id();
  void set_allocated_peer_id(::std::string* peer_id);

  // optional int64 last_active_ms = 2;
  bool has_last_active_ms() const;
  void clear_last_active_ms();
  static const int kLastActiveMsFieldNumber = 2;
  ::google::protobuf::int64 last_active_ms() const;
  void set_last_active_ms(::google::protobuf::int64 value);

  // optional int64 last_state_ms = 3;
  bool has_last_state_ms() const;
  void clear_last_state_ms();
  static const int kLastStateMsFieldNumber = 3;
  ::google::protobuf::int64 last_state_ms() const;
  void set_last_state_ms(::google::protobuf::int64 value);

  // optional int32 state = 5;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 5;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.WorkNode)
 private:
  void set_has_peer_id();
  void clear_has_peer_id();
  void set_has_last_active_ms();
  void clear_has_last_active_ms();
  void set_has_last_state_ms();
  void clear_has_last_state_ms();
  void set_has_state();
  void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard > shards_;
  ::google::protobuf::internal::ArenaStringPtr peer_id_;
  ::google::protobuf::int64 last_active_ms_;
  ::google::protobuf::int64 last_state_ms_;
  ::google::protobuf::int32 state_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClusterState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.ClusterState) */ {
 public:
  ClusterState();
  virtual ~ClusterState();

  ClusterState(const ClusterState& from);

  inline ClusterState& operator=(const ClusterState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClusterState(ClusterState&& from) noexcept
    : ClusterState() {
    *this = ::std::move(from);
  }

  inline ClusterState& operator=(ClusterState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClusterState* internal_default_instance() {
    return reinterpret_cast<const ClusterState*>(
               &_ClusterState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ClusterState* other);
  friend void swap(ClusterState& a, ClusterState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClusterState* New() const final {
    return CreateMaybeMessage<ClusterState>(NULL);
  }

  ClusterState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClusterState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClusterState& from);
  void MergeFrom(const ClusterState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClusterState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .elasticfaiss.WorkNode nodes = 2;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 2;
  ::elasticfaiss::WorkNode* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode >*
      mutable_nodes();
  const ::elasticfaiss::WorkNode& nodes(int index) const;
  ::elasticfaiss::WorkNode* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode >&
      nodes() const;

  // optional int64 update_ms = 1;
  bool has_update_ms() const;
  void clear_update_ms();
  static const int kUpdateMsFieldNumber = 1;
  ::google::protobuf::int64 update_ms() const;
  void set_update_ms(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.ClusterState)
 private:
  void set_has_update_ms();
  void clear_has_update_ms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode > nodes_;
  ::google::protobuf::int64 update_ms_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MasterSnapshot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.MasterSnapshot) */ {
 public:
  MasterSnapshot();
  virtual ~MasterSnapshot();

  MasterSnapshot(const MasterSnapshot& from);

  inline MasterSnapshot& operator=(const MasterSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MasterSnapshot(MasterSnapshot&& from) noexcept
    : MasterSnapshot() {
    *this = ::std::move(from);
  }

  inline MasterSnapshot& operator=(MasterSnapshot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterSnapshot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MasterSnapshot* internal_default_instance() {
    return reinterpret_cast<const MasterSnapshot*>(
               &_MasterSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MasterSnapshot* other);
  friend void swap(MasterSnapshot& a, MasterSnapshot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MasterSnapshot* New() const final {
    return CreateMaybeMessage<MasterSnapshot>(NULL);
  }

  MasterSnapshot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MasterSnapshot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MasterSnapshot& from);
  void MergeFrom(const MasterSnapshot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterSnapshot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .elasticfaiss.IndexConf index = 2;
  int index_size() const;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::elasticfaiss::IndexConf* mutable_index(int index);
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::IndexConf >*
      mutable_index();
  const ::elasticfaiss::IndexConf& index(int index) const;
  ::elasticfaiss::IndexConf* add_index();
  const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::IndexConf >&
      index() const;

  // optional .elasticfaiss.ClusterState state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  private:
  const ::elasticfaiss::ClusterState& _internal_state() const;
  public:
  const ::elasticfaiss::ClusterState& state() const;
  ::elasticfaiss::ClusterState* release_state();
  ::elasticfaiss::ClusterState* mutable_state();
  void set_allocated_state(::elasticfaiss::ClusterState* state);

  // optional .elasticfaiss.ClusterSettings settings = 3;
  bool has_settings() const;
  void clear_settings();
  static const int kSettingsFieldNumber = 3;
  private:
  const ::elasticfaiss::ClusterSettings& _internal_settings() const;
  public:
  const ::elasticfaiss::ClusterSettings& settings() const;
  ::elasticfaiss::ClusterSettings* release_settings();
  ::elasticfaiss::ClusterSettings* mutable_settings();
  void set_allocated_settings(::elasticfaiss::ClusterSettings* settings);

  // @@protoc_insertion_point(class_scope:elasticfaiss.MasterSnapshot)
 private:
  void set_has_state();
  void clear_has_state();
  void set_has_settings();
  void clear_has_settings();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::IndexConf > index_;
  ::elasticfaiss::ClusterState* state_;
  ::elasticfaiss::ClusterSettings* settings_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BootstrapRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.BootstrapRequest) */ {
 public:
  BootstrapRequest();
  virtual ~BootstrapRequest();

  BootstrapRequest(const BootstrapRequest& from);

  inline BootstrapRequest& operator=(const BootstrapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BootstrapRequest(BootstrapRequest&& from) noexcept
    : BootstrapRequest() {
    *this = ::std::move(from);
  }

  inline BootstrapRequest& operator=(BootstrapRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BootstrapRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BootstrapRequest* internal_default_instance() {
    return reinterpret_cast<const BootstrapRequest*>(
               &_BootstrapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BootstrapRequest* other);
  friend void swap(BootstrapRequest& a, BootstrapRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BootstrapRequest* New() const final {
    return CreateMaybeMessage<BootstrapRequest>(NULL);
  }

  BootstrapRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BootstrapRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BootstrapRequest& from);
  void MergeFrom(const BootstrapRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BootstrapRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string node_peer = 1;
  bool has_node_peer() const;
  void clear_node_peer();
  static const int kNodePeerFieldNumber = 1;
  const ::std::string& node_peer() const;
  void set_node_peer(const ::std::string& value);
  #if LANG_CXX11
  void set_node_peer(::std::string&& value);
  #endif
  void set_node_peer(const char* value);
  void set_node_peer(const char* value, size_t size);
  ::std::string* mutable_node_peer();
  ::std::string* release_node_peer();
  void set_allocated_node_peer(::std::string* node_peer);

  // optional int64 boot_ms = 2;
  bool has_boot_ms() const;
  void clear_boot_ms();
  static const int kBootMsFieldNumber = 2;
  ::google::protobuf::int64 boot_ms() const;
  void set_boot_ms(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.BootstrapRequest)
 private:
  void set_has_node_peer();
  void clear_has_node_peer();
  void set_has_boot_ms();
  void clear_has_boot_ms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr node_peer_;
  ::google::protobuf::int64 boot_ms_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BootstrapResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.BootstrapResponse) */ {
 public:
  BootstrapResponse();
  virtual ~BootstrapResponse();

  BootstrapResponse(const BootstrapResponse& from);

  inline BootstrapResponse& operator=(const BootstrapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BootstrapResponse(BootstrapResponse&& from) noexcept
    : BootstrapResponse() {
    *this = ::std::move(from);
  }

  inline BootstrapResponse& operator=(BootstrapResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BootstrapResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BootstrapResponse* internal_default_instance() {
    return reinterpret_cast<const BootstrapResponse*>(
               &_BootstrapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BootstrapResponse* other);
  friend void swap(BootstrapResponse& a, BootstrapResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BootstrapResponse* New() const final {
    return CreateMaybeMessage<BootstrapResponse>(NULL);
  }

  BootstrapResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BootstrapResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BootstrapResponse& from);
  void MergeFrom(const BootstrapResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BootstrapResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .elasticfaiss.WorkNode nodes = 3;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 3;
  ::elasticfaiss::WorkNode* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode >*
      mutable_nodes();
  const ::elasticfaiss::WorkNode& nodes(int index) const;
  ::elasticfaiss::WorkNode* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode >&
      nodes() const;

  // repeated .elasticfaiss.IndexShardConf shards = 4;
  int shards_size() const;
  void clear_shards();
  static const int kShardsFieldNumber = 4;
  ::elasticfaiss::IndexShardConf* mutable_shards(int index);
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::IndexShardConf >*
      mutable_shards();
  const ::elasticfaiss::IndexShardConf& shards(int index) const;
  ::elasticfaiss::IndexShardConf* add_shards();
  const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::IndexShardConf >&
      shards() const;

  // optional string redirect = 2;
  bool has_redirect() const;
  void clear_redirect();
  static const int kRedirectFieldNumber = 2;
  const ::std::string& redirect() const;
  void set_redirect(const ::std::string& value);
  #if LANG_CXX11
  void set_redirect(::std::string&& value);
  #endif
  void set_redirect(const char* value);
  void set_redirect(const char* value, size_t size);
  ::std::string* mutable_redirect();
  ::std::string* release_redirect();
  void set_allocated_redirect(::std::string* redirect);

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.BootstrapResponse)
 private:
  void set_has_success();
  void clear_has_success();
  void set_has_redirect();
  void clear_has_redirect();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode > nodes_;
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::IndexShardConf > shards_;
  ::google::protobuf::internal::ArenaStringPtr redirect_;
  bool success_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeHeartbeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.NodeHeartbeatRequest) */ {
 public:
  NodeHeartbeatRequest();
  virtual ~NodeHeartbeatRequest();

  NodeHeartbeatRequest(const NodeHeartbeatRequest& from);

  inline NodeHeartbeatRequest& operator=(const NodeHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeHeartbeatRequest(NodeHeartbeatRequest&& from) noexcept
    : NodeHeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline NodeHeartbeatRequest& operator=(NodeHeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeHeartbeatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const NodeHeartbeatRequest*>(
               &_NodeHeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(NodeHeartbeatRequest* other);
  friend void swap(NodeHeartbeatRequest& a, NodeHeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeHeartbeatRequest* New() const final {
    return CreateMaybeMessage<NodeHeartbeatRequest>(NULL);
  }

  NodeHeartbeatRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeHeartbeatRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeHeartbeatRequest& from);
  void MergeFrom(const NodeHeartbeatRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeHeartbeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .elasticfaiss.Shard shards = 3;
  int shards_size() const;
  void clear_shards();
  static const int kShardsFieldNumber = 3;
  ::elasticfaiss::Shard* mutable_shards(int index);
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard >*
      mutable_shards();
  const ::elasticfaiss::Shard& shards(int index) const;
  ::elasticfaiss::Shard* add_shards();
  const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard >&
      shards() const;

  // required string node_peer = 1;
  bool has_node_peer() const;
  void clear_node_peer();
  static const int kNodePeerFieldNumber = 1;
  const ::std::string& node_peer() const;
  void set_node_peer(const ::std::string& value);
  #if LANG_CXX11
  void set_node_peer(::std::string&& value);
  #endif
  void set_node_peer(const char* value);
  void set_node_peer(const char* value, size_t size);
  ::std::string* mutable_node_peer();
  ::std::string* release_node_peer();
  void set_allocated_node_peer(::std::string* node_peer);

  // optional int64 active_ms = 2;
  bool has_active_ms() const;
  void clear_active_ms();
  static const int kActiveMsFieldNumber = 2;
  ::google::protobuf::int64 active_ms() const;
  void set_active_ms(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.NodeHeartbeatRequest)
 private:
  void set_has_node_peer();
  void clear_has_node_peer();
  void set_has_active_ms();
  void clear_has_active_ms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard > shards_;
  ::google::protobuf::internal::ArenaStringPtr node_peer_;
  ::google::protobuf::int64 active_ms_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeHeartbeatResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.NodeHeartbeatResponse) */ {
 public:
  NodeHeartbeatResponse();
  virtual ~NodeHeartbeatResponse();

  NodeHeartbeatResponse(const NodeHeartbeatResponse& from);

  inline NodeHeartbeatResponse& operator=(const NodeHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeHeartbeatResponse(NodeHeartbeatResponse&& from) noexcept
    : NodeHeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline NodeHeartbeatResponse& operator=(NodeHeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeHeartbeatResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const NodeHeartbeatResponse*>(
               &_NodeHeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(NodeHeartbeatResponse* other);
  friend void swap(NodeHeartbeatResponse& a, NodeHeartbeatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeHeartbeatResponse* New() const final {
    return CreateMaybeMessage<NodeHeartbeatResponse>(NULL);
  }

  NodeHeartbeatResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeHeartbeatResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeHeartbeatResponse& from);
  void MergeFrom(const NodeHeartbeatResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeHeartbeatResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .elasticfaiss.WorkNode nodes = 3;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 3;
  ::elasticfaiss::WorkNode* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode >*
      mutable_nodes();
  const ::elasticfaiss::WorkNode& nodes(int index) const;
  ::elasticfaiss::WorkNode* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode >&
      nodes() const;

  // optional string redirect = 2;
  bool has_redirect() const;
  void clear_redirect();
  static const int kRedirectFieldNumber = 2;
  const ::std::string& redirect() const;
  void set_redirect(const ::std::string& value);
  #if LANG_CXX11
  void set_redirect(::std::string&& value);
  #endif
  void set_redirect(const char* value);
  void set_redirect(const char* value, size_t size);
  ::std::string* mutable_redirect();
  ::std::string* release_redirect();
  void set_allocated_redirect(::std::string* redirect);

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.NodeHeartbeatResponse)
 private:
  void set_has_success();
  void clear_has_success();
  void set_has_redirect();
  void clear_has_redirect();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode > nodes_;
  ::google::protobuf::internal::ArenaStringPtr redirect_;
  bool success_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetClusterStateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.GetClusterStateRequest) */ {
 public:
  GetClusterStateRequest();
  virtual ~GetClusterStateRequest();

  GetClusterStateRequest(const GetClusterStateRequest& from);

  inline GetClusterStateRequest& operator=(const GetClusterStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetClusterStateRequest(GetClusterStateRequest&& from) noexcept
    : GetClusterStateRequest() {
    *this = ::std::move(from);
  }

  inline GetClusterStateRequest& operator=(GetClusterStateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClusterStateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetClusterStateRequest* internal_default_instance() {
    return reinterpret_cast<const GetClusterStateRequest*>(
               &_GetClusterStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GetClusterStateRequest* other);
  friend void swap(GetClusterStateRequest& a, GetClusterStateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetClusterStateRequest* New() const final {
    return CreateMaybeMessage<GetClusterStateRequest>(NULL);
  }

  GetClusterStateRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetClusterStateRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetClusterStateRequest& from);
  void MergeFrom(const GetClusterStateRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetClusterStateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cluster = 1;
  bool has_cluster() const;
  void clear_cluster();
  static const int kClusterFieldNumber = 1;
  const ::std::string& cluster() const;
  void set_cluster(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster(::std::string&& value);
  #endif
  void set_cluster(const char* value);
  void set_cluster(const char* value, size_t size);
  ::std::string* mutable_cluster();
  ::std::string* release_cluster();
  void set_allocated_cluster(::std::string* cluster);

  // @@protoc_insertion_point(class_scope:elasticfaiss.GetClusterStateRequest)
 private:
  void set_has_cluster();
  void clear_has_cluster();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr cluster_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetClusterStateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.GetClusterStateResponse) */ {
 public:
  GetClusterStateResponse();
  virtual ~GetClusterStateResponse();

  GetClusterStateResponse(const GetClusterStateResponse& from);

  inline GetClusterStateResponse& operator=(const GetClusterStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetClusterStateResponse(GetClusterStateResponse&& from) noexcept
    : GetClusterStateResponse() {
    *this = ::std::move(from);
  }

  inline GetClusterStateResponse& operator=(GetClusterStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetClusterStateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetClusterStateResponse* internal_default_instance() {
    return reinterpret_cast<const GetClusterStateResponse*>(
               &_GetClusterStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetClusterStateResponse* other);
  friend void swap(GetClusterStateResponse& a, GetClusterStateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetClusterStateResponse* New() const final {
    return CreateMaybeMessage<GetClusterStateResponse>(NULL);
  }

  GetClusterStateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetClusterStateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetClusterStateResponse& from);
  void MergeFrom(const GetClusterStateResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetClusterStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string redirect = 2;
  bool has_redirect() const;
  void clear_redirect();
  static const int kRedirectFieldNumber = 2;
  const ::std::string& redirect() const;
  void set_redirect(const ::std::string& value);
  #if LANG_CXX11
  void set_redirect(::std::string&& value);
  #endif
  void set_redirect(const char* value);
  void set_redirect(const char* value, size_t size);
  ::std::string* mutable_redirect();
  ::std::string* release_redirect();
  void set_allocated_redirect(::std::string* redirect);

  // optional .elasticfaiss.ClusterState state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  private:
  const ::elasticfaiss::ClusterState& _internal_state() const;
  public:
  const ::elasticfaiss::ClusterState& state() const;
  ::elasticfaiss::ClusterState* release_state();
  ::elasticfaiss::ClusterState* mutable_state();
  void set_allocated_state(::elasticfaiss::ClusterState* state);

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.GetClusterStateResponse)
 private:
  void set_has_success();
  void clear_has_success();
  void set_has_redirect();
  void clear_has_redirect();
  void set_has_state();
  void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr redirect_;
  ::elasticfaiss::ClusterState* state_;
  bool success_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateIndexRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.CreateIndexRequest) */ {
 public:
  CreateIndexRequest();
  virtual ~CreateIndexRequest();

  CreateIndexRequest(const CreateIndexRequest& from);

  inline CreateIndexRequest& operator=(const CreateIndexRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateIndexRequest(CreateIndexRequest&& from) noexcept
    : CreateIndexRequest() {
    *this = ::std::move(from);
  }

  inline CreateIndexRequest& operator=(CreateIndexRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateIndexRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateIndexRequest* internal_default_instance() {
    return reinterpret_cast<const CreateIndexRequest*>(
               &_CreateIndexRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CreateIndexRequest* other);
  friend void swap(CreateIndexRequest& a, CreateIndexRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateIndexRequest* New() const final {
    return CreateMaybeMessage<CreateIndexRequest>(NULL);
  }

  CreateIndexRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateIndexRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateIndexRequest& from);
  void MergeFrom(const CreateIndexRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateIndexRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .elasticfaiss.IndexConf conf = 1;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 1;
  private:
  const ::elasticfaiss::IndexConf& _internal_conf() const;
  public:
  const ::elasticfaiss::IndexConf& conf() const;
  ::elasticfaiss::IndexConf* release_conf();
  ::elasticfaiss::IndexConf* mutable_conf();
  void set_allocated_conf(::elasticfaiss::IndexConf* conf);

  // @@protoc_insertion_point(class_scope:elasticfaiss.CreateIndexRequest)
 private:
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::elasticfaiss::IndexConf* conf_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateIndexResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.CreateIndexResponse) */ {
 public:
  CreateIndexResponse();
  virtual ~CreateIndexResponse();

  CreateIndexResponse(const CreateIndexResponse& from);

  inline CreateIndexResponse& operator=(const CreateIndexResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateIndexResponse(CreateIndexResponse&& from) noexcept
    : CreateIndexResponse() {
    *this = ::std::move(from);
  }

  inline CreateIndexResponse& operator=(CreateIndexResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateIndexResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateIndexResponse* internal_default_instance() {
    return reinterpret_cast<const CreateIndexResponse*>(
               &_CreateIndexResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(CreateIndexResponse* other);
  friend void swap(CreateIndexResponse& a, CreateIndexResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateIndexResponse* New() const final {
    return CreateMaybeMessage<CreateIndexResponse>(NULL);
  }

  CreateIndexResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateIndexResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateIndexResponse& from);
  void MergeFrom(const CreateIndexResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateIndexResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string redirect = 2;
  bool has_redirect() const;
  void clear_redirect();
  static const int kRedirectFieldNumber = 2;
  const ::std::string& redirect() const;
  void set_redirect(const ::std::string& value);
  #if LANG_CXX11
  void set_redirect(::std::string&& value);
  #endif
  void set_redirect(const char* value);
  void set_redirect(const char* value, size_t size);
  ::std::string* mutable_redirect();
  ::std::string* release_redirect();
  void set_allocated_redirect(::std::string* redirect);

  // optional string error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.CreateIndexResponse)
 private:
  void set_has_success();
  void clear_has_success();
  void set_has_redirect();
  void clear_has_redirect();
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr redirect_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  bool success_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteIndexRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.DeleteIndexRequest) */ {
 public:
  DeleteIndexRequest();
  virtual ~DeleteIndexRequest();

  DeleteIndexRequest(const DeleteIndexRequest& from);

  inline DeleteIndexRequest& operator=(const DeleteIndexRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteIndexRequest(DeleteIndexRequest&& from) noexcept
    : DeleteIndexRequest() {
    *this = ::std::move(from);
  }

  inline DeleteIndexRequest& operator=(DeleteIndexRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteIndexRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteIndexRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteIndexRequest*>(
               &_DeleteIndexRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(DeleteIndexRequest* other);
  friend void swap(DeleteIndexRequest& a, DeleteIndexRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteIndexRequest* New() const final {
    return CreateMaybeMessage<DeleteIndexRequest>(NULL);
  }

  DeleteIndexRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteIndexRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteIndexRequest& from);
  void MergeFrom(const DeleteIndexRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteIndexRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string index_name = 1;
  bool has_index_name() const;
  void clear_index_name();
  static const int kIndexNameFieldNumber = 1;
  const ::std::string& index_name() const;
  void set_index_name(const ::std::string& value);
  #if LANG_CXX11
  void set_index_name(::std::string&& value);
  #endif
  void set_index_name(const char* value);
  void set_index_name(const char* value, size_t size);
  ::std::string* mutable_index_name();
  ::std::string* release_index_name();
  void set_allocated_index_name(::std::string* index_name);

  // @@protoc_insertion_point(class_scope:elasticfaiss.DeleteIndexRequest)
 private:
  void set_has_index_name();
  void clear_has_index_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr index_name_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteIndexResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.DeleteIndexResponse) */ {
 public:
  DeleteIndexResponse();
  virtual ~DeleteIndexResponse();

  DeleteIndexResponse(const DeleteIndexResponse& from);

  inline DeleteIndexResponse& operator=(const DeleteIndexResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteIndexResponse(DeleteIndexResponse&& from) noexcept
    : DeleteIndexResponse() {
    *this = ::std::move(from);
  }

  inline DeleteIndexResponse& operator=(DeleteIndexResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteIndexResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteIndexResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteIndexResponse*>(
               &_DeleteIndexResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(DeleteIndexResponse* other);
  friend void swap(DeleteIndexResponse& a, DeleteIndexResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteIndexResponse* New() const final {
    return CreateMaybeMessage<DeleteIndexResponse>(NULL);
  }

  DeleteIndexResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteIndexResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteIndexResponse& from);
  void MergeFrom(const DeleteIndexResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteIndexResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string redirect = 2;
  bool has_redirect() const;
  void clear_redirect();
  static const int kRedirectFieldNumber = 2;
  const ::std::string& redirect() const;
  void set_redirect(const ::std::string& value);
  #if LANG_CXX11
  void set_redirect(::std::string&& value);
  #endif
  void set_redirect(const char* value);
  void set_redirect(const char* value, size_t size);
  ::std::string* mutable_redirect();
  ::std::string* release_redirect();
  void set_allocated_redirect(::std::string* redirect);

  // optional string error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.DeleteIndexResponse)
 private:
  void set_has_success();
  void clear_has_success();
  void set_has_redirect();
  void clear_has_redirect();
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr redirect_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  bool success_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateIndexRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.UpdateIndexRequest) */ {
 public:
  UpdateIndexRequest();
  virtual ~UpdateIndexRequest();

  UpdateIndexRequest(const UpdateIndexRequest& from);

  inline UpdateIndexRequest& operator=(const UpdateIndexRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateIndexRequest(UpdateIndexRequest&& from) noexcept
    : UpdateIndexRequest() {
    *this = ::std::move(from);
  }

  inline UpdateIndexRequest& operator=(UpdateIndexRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateIndexRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateIndexRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateIndexRequest*>(
               &_UpdateIndexRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(UpdateIndexRequest* other);
  friend void swap(UpdateIndexRequest& a, UpdateIndexRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateIndexRequest* New() const final {
    return CreateMaybeMessage<UpdateIndexRequest>(NULL);
  }

  UpdateIndexRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateIndexRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateIndexRequest& from);
  void MergeFrom(const UpdateIndexRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateIndexRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .elasticfaiss.IndexConf conf = 1;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 1;
  private:
  const ::elasticfaiss::IndexConf& _internal_conf() const;
  public:
  const ::elasticfaiss::IndexConf& conf() const;
  ::elasticfaiss::IndexConf* release_conf();
  ::elasticfaiss::IndexConf* mutable_conf();
  void set_allocated_conf(::elasticfaiss::IndexConf* conf);

  // @@protoc_insertion_point(class_scope:elasticfaiss.UpdateIndexRequest)
 private:
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::elasticfaiss::IndexConf* conf_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateIndexResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.UpdateIndexResponse) */ {
 public:
  UpdateIndexResponse();
  virtual ~UpdateIndexResponse();

  UpdateIndexResponse(const UpdateIndexResponse& from);

  inline UpdateIndexResponse& operator=(const UpdateIndexResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateIndexResponse(UpdateIndexResponse&& from) noexcept
    : UpdateIndexResponse() {
    *this = ::std::move(from);
  }

  inline UpdateIndexResponse& operator=(UpdateIndexResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateIndexResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateIndexResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateIndexResponse*>(
               &_UpdateIndexResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(UpdateIndexResponse* other);
  friend void swap(UpdateIndexResponse& a, UpdateIndexResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateIndexResponse* New() const final {
    return CreateMaybeMessage<UpdateIndexResponse>(NULL);
  }

  UpdateIndexResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateIndexResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateIndexResponse& from);
  void MergeFrom(const UpdateIndexResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateIndexResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string redirect = 2;
  bool has_redirect() const;
  void clear_redirect();
  static const int kRedirectFieldNumber = 2;
  const ::std::string& redirect() const;
  void set_redirect(const ::std::string& value);
  #if LANG_CXX11
  void set_redirect(::std::string&& value);
  #endif
  void set_redirect(const char* value);
  void set_redirect(const char* value, size_t size);
  ::std::string* mutable_redirect();
  ::std::string* release_redirect();
  void set_allocated_redirect(::std::string* redirect);

  // optional string error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.UpdateIndexResponse)
 private:
  void set_has_success();
  void clear_has_success();
  void set_has_redirect();
  void clear_has_redirect();
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr redirect_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  bool success_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateNodeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.UpdateNodeRequest) */ {
 public:
  UpdateNodeRequest();
  virtual ~UpdateNodeRequest();

  UpdateNodeRequest(const UpdateNodeRequest& from);

  inline UpdateNodeRequest& operator=(const UpdateNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateNodeRequest(UpdateNodeRequest&& from) noexcept
    : UpdateNodeRequest() {
    *this = ::std::move(from);
  }

  inline UpdateNodeRequest& operator=(UpdateNodeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateNodeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateNodeRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateNodeRequest*>(
               &_UpdateNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(UpdateNodeRequest* other);
  friend void swap(UpdateNodeRequest& a, UpdateNodeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateNodeRequest* New() const final {
    return CreateMaybeMessage<UpdateNodeRequest>(NULL);
  }

  UpdateNodeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateNodeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateNodeRequest& from);
  void MergeFrom(const UpdateNodeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNodeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .elasticfaiss.Shard shards = 4;
  int shards_size() const;
  void clear_shards();
  static const int kShardsFieldNumber = 4;
  ::elasticfaiss::Shard* mutable_shards(int index);
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard >*
      mutable_shards();
  const ::elasticfaiss::Shard& shards(int index) const;
  ::elasticfaiss::Shard* add_shards();
  const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard >&
      shards() const;

  // required string peer_id = 1;
  bool has_peer_id() const;
  void clear_peer_id();
  static const int kPeerIdFieldNumber = 1;
  const ::std::string& peer_id() const;
  void set_peer_id(const ::std::string& value);
  #if LANG_CXX11
  void set_peer_id(::std::string&& value);
  #endif
  void set_peer_id(const char* value);
  void set_peer_id(const char* value, size_t size);
  ::std::string* mutable_peer_id();
  ::std::string* release_peer_id();
  void set_allocated_peer_id(::std::string* peer_id);

  // required int64 state_ms = 3;
  bool has_state_ms() const;
  void clear_state_ms();
  static const int kStateMsFieldNumber = 3;
  ::google::protobuf::int64 state_ms() const;
  void set_state_ms(::google::protobuf::int64 value);

  // optional int32 state = 2;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 2;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.UpdateNodeRequest)
 private:
  void set_has_peer_id();
  void clear_has_peer_id();
  void set_has_state();
  void clear_has_state();
  void set_has_state_ms();
  void clear_has_state_ms();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard > shards_;
  ::google::protobuf::internal::ArenaStringPtr peer_id_;
  ::google::protobuf::int64 state_ms_;
  ::google::protobuf::int32 state_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateNodeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.UpdateNodeResponse) */ {
 public:
  UpdateNodeResponse();
  virtual ~UpdateNodeResponse();

  UpdateNodeResponse(const UpdateNodeResponse& from);

  inline UpdateNodeResponse& operator=(const UpdateNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateNodeResponse(UpdateNodeResponse&& from) noexcept
    : UpdateNodeResponse() {
    *this = ::std::move(from);
  }

  inline UpdateNodeResponse& operator=(UpdateNodeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateNodeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateNodeResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateNodeResponse*>(
               &_UpdateNodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(UpdateNodeResponse* other);
  friend void swap(UpdateNodeResponse& a, UpdateNodeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateNodeResponse* New() const final {
    return CreateMaybeMessage<UpdateNodeResponse>(NULL);
  }

  UpdateNodeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateNodeResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateNodeResponse& from);
  void MergeFrom(const UpdateNodeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNodeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string redirect = 2;
  bool has_redirect() const;
  void clear_redirect();
  static const int kRedirectFieldNumber = 2;
  const ::std::string& redirect() const;
  void set_redirect(const ::std::string& value);
  #if LANG_CXX11
  void set_redirect(::std::string&& value);
  #endif
  void set_redirect(const char* value);
  void set_redirect(const char* value, size_t size);
  ::std::string* mutable_redirect();
  ::std::string* release_redirect();
  void set_allocated_redirect(::std::string* redirect);

  // optional string error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.UpdateNodeResponse)
 private:
  void set_has_success();
  void clear_has_success();
  void set_has_redirect();
  void clear_has_redirect();
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr redirect_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  bool success_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateClusterSettingRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.UpdateClusterSettingRequest) */ {
 public:
  UpdateClusterSettingRequest();
  virtual ~UpdateClusterSettingRequest();

  UpdateClusterSettingRequest(const UpdateClusterSettingRequest& from);

  inline UpdateClusterSettingRequest& operator=(const UpdateClusterSettingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateClusterSettingRequest(UpdateClusterSettingRequest&& from) noexcept
    : UpdateClusterSettingRequest() {
    *this = ::std::move(from);
  }

  inline UpdateClusterSettingRequest& operator=(UpdateClusterSettingRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateClusterSettingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateClusterSettingRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateClusterSettingRequest*>(
               &_UpdateClusterSettingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(UpdateClusterSettingRequest* other);
  friend void swap(UpdateClusterSettingRequest& a, UpdateClusterSettingRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateClusterSettingRequest* New() const final {
    return CreateMaybeMessage<UpdateClusterSettingRequest>(NULL);
  }

  UpdateClusterSettingRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateClusterSettingRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateClusterSettingRequest& from);
  void MergeFrom(const UpdateClusterSettingRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateClusterSettingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .elasticfaiss.ClusterSettings settings = 1;
  bool has_settings() const;
  void clear_settings();
  static const int kSettingsFieldNumber = 1;
  private:
  const ::elasticfaiss::ClusterSettings& _internal_settings() const;
  public:
  const ::elasticfaiss::ClusterSettings& settings() const;
  ::elasticfaiss::ClusterSettings* release_settings();
  ::elasticfaiss::ClusterSettings* mutable_settings();
  void set_allocated_settings(::elasticfaiss::ClusterSettings* settings);

  // @@protoc_insertion_point(class_scope:elasticfaiss.UpdateClusterSettingRequest)
 private:
  void set_has_settings();
  void clear_has_settings();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::elasticfaiss::ClusterSettings* settings_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateClusterSettingResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.UpdateClusterSettingResponse) */ {
 public:
  UpdateClusterSettingResponse();
  virtual ~UpdateClusterSettingResponse();

  UpdateClusterSettingResponse(const UpdateClusterSettingResponse& from);

  inline UpdateClusterSettingResponse& operator=(const UpdateClusterSettingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateClusterSettingResponse(UpdateClusterSettingResponse&& from) noexcept
    : UpdateClusterSettingResponse() {
    *this = ::std::move(from);
  }

  inline UpdateClusterSettingResponse& operator=(UpdateClusterSettingResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateClusterSettingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateClusterSettingResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateClusterSettingResponse*>(
               &_UpdateClusterSettingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(UpdateClusterSettingResponse* other);
  friend void swap(UpdateClusterSettingResponse& a, UpdateClusterSettingResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateClusterSettingResponse* New() const final {
    return CreateMaybeMessage<UpdateClusterSettingResponse>(NULL);
  }

  UpdateClusterSettingResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateClusterSettingResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateClusterSettingResponse& from);
  void MergeFrom(const UpdateClusterSettingResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateClusterSettingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string redirect = 2;
  bool has_redirect() const;
  void clear_redirect();
  static const int kRedirectFieldNumber = 2;
  const ::std::string& redirect() const;
  void set_redirect(const ::std::string& value);
  #if LANG_CXX11
  void set_redirect(::std::string&& value);
  #endif
  void set_redirect(const char* value);
  void set_redirect(const char* value, size_t size);
  ::std::string* mutable_redirect();
  ::std::string* release_redirect();
  void set_allocated_redirect(::std::string* redirect);

  // optional string error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // required bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.UpdateClusterSettingResponse)
 private:
  void set_has_success();
  void clear_has_success();
  void set_has_redirect();
  void clear_has_redirect();
  void set_has_error();
  void clear_has_error();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr redirect_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  bool success_;
  friend struct ::protobuf_master_2eproto::TableStruct;
};
// ===================================================================

class MasterService_Stub;

class MasterService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline MasterService() {};
 public:
  virtual ~MasterService();

  typedef MasterService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void bootstrap(::google::protobuf::RpcController* controller,
                       const ::elasticfaiss::BootstrapRequest* request,
                       ::elasticfaiss::BootstrapResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void node_heartbeat(::google::protobuf::RpcController* controller,
                       const ::elasticfaiss::NodeHeartbeatRequest* request,
                       ::elasticfaiss::NodeHeartbeatResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void cluster_setting(::google::protobuf::RpcController* controller,
                       const ::elasticfaiss::UpdateClusterSettingRequest* request,
                       ::elasticfaiss::UpdateClusterSettingResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void get_cluster_state(::google::protobuf::RpcController* controller,
                       const ::elasticfaiss::GetClusterStateRequest* request,
                       ::elasticfaiss::GetClusterStateResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void create_index(::google::protobuf::RpcController* controller,
                       const ::elasticfaiss::CreateIndexRequest* request,
                       ::elasticfaiss::CreateIndexResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void delete_index(::google::protobuf::RpcController* controller,
                       const ::elasticfaiss::DeleteIndexRequest* request,
                       ::elasticfaiss::DeleteIndexResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void update_index(::google::protobuf::RpcController* controller,
                       const ::elasticfaiss::UpdateIndexRequest* request,
                       ::elasticfaiss::UpdateIndexResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MasterService);
};

class MasterService_Stub : public MasterService {
 public:
  MasterService_Stub(::google::protobuf::RpcChannel* channel);
  MasterService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~MasterService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements MasterService ------------------------------------------

  void bootstrap(::google::protobuf::RpcController* controller,
                       const ::elasticfaiss::BootstrapRequest* request,
                       ::elasticfaiss::BootstrapResponse* response,
                       ::google::protobuf::Closure* done);
  void node_heartbeat(::google::protobuf::RpcController* controller,
                       const ::elasticfaiss::NodeHeartbeatRequest* request,
                       ::elasticfaiss::NodeHeartbeatResponse* response,
                       ::google::protobuf::Closure* done);
  void cluster_setting(::google::protobuf::RpcController* controller,
                       const ::elasticfaiss::UpdateClusterSettingRequest* request,
                       ::elasticfaiss::UpdateClusterSettingResponse* response,
                       ::google::protobuf::Closure* done);
  void get_cluster_state(::google::protobuf::RpcController* controller,
                       const ::elasticfaiss::GetClusterStateRequest* request,
                       ::elasticfaiss::GetClusterStateResponse* response,
                       ::google::protobuf::Closure* done);
  void create_index(::google::protobuf::RpcController* controller,
                       const ::elasticfaiss::CreateIndexRequest* request,
                       ::elasticfaiss::CreateIndexResponse* response,
                       ::google::protobuf::Closure* done);
  void delete_index(::google::protobuf::RpcController* controller,
                       const ::elasticfaiss::DeleteIndexRequest* request,
                       ::elasticfaiss::DeleteIndexResponse* response,
                       ::google::protobuf::Closure* done);
  void update_index(::google::protobuf::RpcController* controller,
                       const ::elasticfaiss::UpdateIndexRequest* request,
                       ::elasticfaiss::UpdateIndexResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MasterService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ClusterSettings

// optional int32 shard_allocation_after_timeout_secs = 1 [default = 60];
inline bool ClusterSettings::has_shard_allocation_after_timeout_secs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClusterSettings::set_has_shard_allocation_after_timeout_secs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClusterSettings::clear_has_shard_allocation_after_timeout_secs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClusterSettings::clear_shard_allocation_after_timeout_secs() {
  shard_allocation_after_timeout_secs_ = 60;
  clear_has_shard_allocation_after_timeout_secs();
}
inline ::google::protobuf::int32 ClusterSettings::shard_allocation_after_timeout_secs() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.ClusterSettings.shard_allocation_after_timeout_secs)
  return shard_allocation_after_timeout_secs_;
}
inline void ClusterSettings::set_shard_allocation_after_timeout_secs(::google::protobuf::int32 value) {
  set_has_shard_allocation_after_timeout_secs();
  shard_allocation_after_timeout_secs_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.ClusterSettings.shard_allocation_after_timeout_secs)
}

// optional int32 total_shards_per_node = 2 [default = -1];
inline bool ClusterSettings::has_total_shards_per_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClusterSettings::set_has_total_shards_per_node() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClusterSettings::clear_has_total_shards_per_node() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClusterSettings::clear_total_shards_per_node() {
  total_shards_per_node_ = -1;
  clear_has_total_shards_per_node();
}
inline ::google::protobuf::int32 ClusterSettings::total_shards_per_node() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.ClusterSettings.total_shards_per_node)
  return total_shards_per_node_;
}
inline void ClusterSettings::set_total_shards_per_node(::google::protobuf::int32 value) {
  set_has_total_shards_per_node();
  total_shards_per_node_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.ClusterSettings.total_shards_per_node)
}

// optional int32 index_rpc_timeout_ms = 3 [default = 10000];
inline bool ClusterSettings::has_index_rpc_timeout_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClusterSettings::set_has_index_rpc_timeout_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClusterSettings::clear_has_index_rpc_timeout_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClusterSettings::clear_index_rpc_timeout_ms() {
  index_rpc_timeout_ms_ = 10000;
  clear_has_index_rpc_timeout_ms();
}
inline ::google::protobuf::int32 ClusterSettings::index_rpc_timeout_ms() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.ClusterSettings.index_rpc_timeout_ms)
  return index_rpc_timeout_ms_;
}
inline void ClusterSettings::set_index_rpc_timeout_ms(::google::protobuf::int32 value) {
  set_has_index_rpc_timeout_ms();
  index_rpc_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.ClusterSettings.index_rpc_timeout_ms)
}

// optional int32 index_rpc_max_retry = 4 [default = 2];
inline bool ClusterSettings::has_index_rpc_max_retry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClusterSettings::set_has_index_rpc_max_retry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClusterSettings::clear_has_index_rpc_max_retry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClusterSettings::clear_index_rpc_max_retry() {
  index_rpc_max_retry_ = 2;
  clear_has_index_rpc_max_retry();
}
inline ::google::protobuf::int32 ClusterSettings::index_rpc_max_retry() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.ClusterSettings.index_rpc_max_retry)
  return index_rpc_max_retry_;
}
inline void ClusterSettings::set_index_rpc_max_retry(::google::protobuf::int32 value) {
  set_has_index_rpc_max_retry();
  index_rpc_max_retry_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.ClusterSettings.index_rpc_max_retry)
}

// -------------------------------------------------------------------

// WorkNode

// required string peer_id = 1;
inline bool WorkNode::has_peer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorkNode::set_has_peer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorkNode::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorkNode::clear_peer_id() {
  peer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer_id();
}
inline const ::std::string& WorkNode::peer_id() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.WorkNode.peer_id)
  return peer_id_.GetNoArena();
}
inline void WorkNode::set_peer_id(const ::std::string& value) {
  set_has_peer_id();
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.WorkNode.peer_id)
}
#if LANG_CXX11
inline void WorkNode::set_peer_id(::std::string&& value) {
  set_has_peer_id();
  peer_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.WorkNode.peer_id)
}
#endif
inline void WorkNode::set_peer_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer_id();
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.WorkNode.peer_id)
}
inline void WorkNode::set_peer_id(const char* value, size_t size) {
  set_has_peer_id();
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.WorkNode.peer_id)
}
inline ::std::string* WorkNode::mutable_peer_id() {
  set_has_peer_id();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.WorkNode.peer_id)
  return peer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkNode::release_peer_id() {
  // @@protoc_insertion_point(field_release:elasticfaiss.WorkNode.peer_id)
  if (!has_peer_id()) {
    return NULL;
  }
  clear_has_peer_id();
  return peer_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkNode::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id != NULL) {
    set_has_peer_id();
  } else {
    clear_has_peer_id();
  }
  peer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_id);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.WorkNode.peer_id)
}

// optional int64 last_active_ms = 2;
inline bool WorkNode::has_last_active_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorkNode::set_has_last_active_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorkNode::clear_has_last_active_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorkNode::clear_last_active_ms() {
  last_active_ms_ = GOOGLE_LONGLONG(0);
  clear_has_last_active_ms();
}
inline ::google::protobuf::int64 WorkNode::last_active_ms() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.WorkNode.last_active_ms)
  return last_active_ms_;
}
inline void WorkNode::set_last_active_ms(::google::protobuf::int64 value) {
  set_has_last_active_ms();
  last_active_ms_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.WorkNode.last_active_ms)
}

// optional int64 last_state_ms = 3;
inline bool WorkNode::has_last_state_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WorkNode::set_has_last_state_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WorkNode::clear_has_last_state_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WorkNode::clear_last_state_ms() {
  last_state_ms_ = GOOGLE_LONGLONG(0);
  clear_has_last_state_ms();
}
inline ::google::protobuf::int64 WorkNode::last_state_ms() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.WorkNode.last_state_ms)
  return last_state_ms_;
}
inline void WorkNode::set_last_state_ms(::google::protobuf::int64 value) {
  set_has_last_state_ms();
  last_state_ms_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.WorkNode.last_state_ms)
}

// repeated .elasticfaiss.Shard shards = 4;
inline int WorkNode::shards_size() const {
  return shards_.size();
}
inline ::elasticfaiss::Shard* WorkNode::mutable_shards(int index) {
  // @@protoc_insertion_point(field_mutable:elasticfaiss.WorkNode.shards)
  return shards_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard >*
WorkNode::mutable_shards() {
  // @@protoc_insertion_point(field_mutable_list:elasticfaiss.WorkNode.shards)
  return &shards_;
}
inline const ::elasticfaiss::Shard& WorkNode::shards(int index) const {
  // @@protoc_insertion_point(field_get:elasticfaiss.WorkNode.shards)
  return shards_.Get(index);
}
inline ::elasticfaiss::Shard* WorkNode::add_shards() {
  // @@protoc_insertion_point(field_add:elasticfaiss.WorkNode.shards)
  return shards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard >&
WorkNode::shards() const {
  // @@protoc_insertion_point(field_list:elasticfaiss.WorkNode.shards)
  return shards_;
}

// optional int32 state = 5;
inline bool WorkNode::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WorkNode::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WorkNode::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WorkNode::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 WorkNode::state() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.WorkNode.state)
  return state_;
}
inline void WorkNode::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.WorkNode.state)
}

// -------------------------------------------------------------------

// ClusterState

// optional int64 update_ms = 1;
inline bool ClusterState::has_update_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClusterState::set_has_update_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClusterState::clear_has_update_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClusterState::clear_update_ms() {
  update_ms_ = GOOGLE_LONGLONG(0);
  clear_has_update_ms();
}
inline ::google::protobuf::int64 ClusterState::update_ms() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.ClusterState.update_ms)
  return update_ms_;
}
inline void ClusterState::set_update_ms(::google::protobuf::int64 value) {
  set_has_update_ms();
  update_ms_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.ClusterState.update_ms)
}

// repeated .elasticfaiss.WorkNode nodes = 2;
inline int ClusterState::nodes_size() const {
  return nodes_.size();
}
inline void ClusterState::clear_nodes() {
  nodes_.Clear();
}
inline ::elasticfaiss::WorkNode* ClusterState::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:elasticfaiss.ClusterState.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode >*
ClusterState::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:elasticfaiss.ClusterState.nodes)
  return &nodes_;
}
inline const ::elasticfaiss::WorkNode& ClusterState::nodes(int index) const {
  // @@protoc_insertion_point(field_get:elasticfaiss.ClusterState.nodes)
  return nodes_.Get(index);
}
inline ::elasticfaiss::WorkNode* ClusterState::add_nodes() {
  // @@protoc_insertion_point(field_add:elasticfaiss.ClusterState.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode >&
ClusterState::nodes() const {
  // @@protoc_insertion_point(field_list:elasticfaiss.ClusterState.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// MasterSnapshot

// optional .elasticfaiss.ClusterState state = 1;
inline bool MasterSnapshot::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterSnapshot::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterSnapshot::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterSnapshot::clear_state() {
  if (state_ != NULL) state_->Clear();
  clear_has_state();
}
inline const ::elasticfaiss::ClusterState& MasterSnapshot::_internal_state() const {
  return *state_;
}
inline const ::elasticfaiss::ClusterState& MasterSnapshot::state() const {
  const ::elasticfaiss::ClusterState* p = state_;
  // @@protoc_insertion_point(field_get:elasticfaiss.MasterSnapshot.state)
  return p != NULL ? *p : *reinterpret_cast<const ::elasticfaiss::ClusterState*>(
      &::elasticfaiss::_ClusterState_default_instance_);
}
inline ::elasticfaiss::ClusterState* MasterSnapshot::release_state() {
  // @@protoc_insertion_point(field_release:elasticfaiss.MasterSnapshot.state)
  clear_has_state();
  ::elasticfaiss::ClusterState* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::elasticfaiss::ClusterState* MasterSnapshot::mutable_state() {
  set_has_state();
  if (state_ == NULL) {
    auto* p = CreateMaybeMessage<::elasticfaiss::ClusterState>(GetArenaNoVirtual());
    state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:elasticfaiss.MasterSnapshot.state)
  return state_;
}
inline void MasterSnapshot::set_allocated_state(::elasticfaiss::ClusterState* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    set_has_state();
  } else {
    clear_has_state();
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.MasterSnapshot.state)
}

// repeated .elasticfaiss.IndexConf index = 2;
inline int MasterSnapshot::index_size() const {
  return index_.size();
}
inline ::elasticfaiss::IndexConf* MasterSnapshot::mutable_index(int index) {
  // @@protoc_insertion_point(field_mutable:elasticfaiss.MasterSnapshot.index)
  return index_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::elasticfaiss::IndexConf >*
MasterSnapshot::mutable_index() {
  // @@protoc_insertion_point(field_mutable_list:elasticfaiss.MasterSnapshot.index)
  return &index_;
}
inline const ::elasticfaiss::IndexConf& MasterSnapshot::index(int index) const {
  // @@protoc_insertion_point(field_get:elasticfaiss.MasterSnapshot.index)
  return index_.Get(index);
}
inline ::elasticfaiss::IndexConf* MasterSnapshot::add_index() {
  // @@protoc_insertion_point(field_add:elasticfaiss.MasterSnapshot.index)
  return index_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::IndexConf >&
MasterSnapshot::index() const {
  // @@protoc_insertion_point(field_list:elasticfaiss.MasterSnapshot.index)
  return index_;
}

// optional .elasticfaiss.ClusterSettings settings = 3;
inline bool MasterSnapshot::has_settings() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterSnapshot::set_has_settings() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterSnapshot::clear_has_settings() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterSnapshot::clear_settings() {
  if (settings_ != NULL) settings_->Clear();
  clear_has_settings();
}
inline const ::elasticfaiss::ClusterSettings& MasterSnapshot::_internal_settings() const {
  return *settings_;
}
inline const ::elasticfaiss::ClusterSettings& MasterSnapshot::settings() const {
  const ::elasticfaiss::ClusterSettings* p = settings_;
  // @@protoc_insertion_point(field_get:elasticfaiss.MasterSnapshot.settings)
  return p != NULL ? *p : *reinterpret_cast<const ::elasticfaiss::ClusterSettings*>(
      &::elasticfaiss::_ClusterSettings_default_instance_);
}
inline ::elasticfaiss::ClusterSettings* MasterSnapshot::release_settings() {
  // @@protoc_insertion_point(field_release:elasticfaiss.MasterSnapshot.settings)
  clear_has_settings();
  ::elasticfaiss::ClusterSettings* temp = settings_;
  settings_ = NULL;
  return temp;
}
inline ::elasticfaiss::ClusterSettings* MasterSnapshot::mutable_settings() {
  set_has_settings();
  if (settings_ == NULL) {
    auto* p = CreateMaybeMessage<::elasticfaiss::ClusterSettings>(GetArenaNoVirtual());
    settings_ = p;
  }
  // @@protoc_insertion_point(field_mutable:elasticfaiss.MasterSnapshot.settings)
  return settings_;
}
inline void MasterSnapshot::set_allocated_settings(::elasticfaiss::ClusterSettings* settings) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete settings_;
  }
  if (settings) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      settings = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    set_has_settings();
  } else {
    clear_has_settings();
  }
  settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.MasterSnapshot.settings)
}

// -------------------------------------------------------------------

// BootstrapRequest

// required string node_peer = 1;
inline bool BootstrapRequest::has_node_peer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BootstrapRequest::set_has_node_peer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BootstrapRequest::clear_has_node_peer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BootstrapRequest::clear_node_peer() {
  node_peer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_node_peer();
}
inline const ::std::string& BootstrapRequest::node_peer() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.BootstrapRequest.node_peer)
  return node_peer_.GetNoArena();
}
inline void BootstrapRequest::set_node_peer(const ::std::string& value) {
  set_has_node_peer();
  node_peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.BootstrapRequest.node_peer)
}
#if LANG_CXX11
inline void BootstrapRequest::set_node_peer(::std::string&& value) {
  set_has_node_peer();
  node_peer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.BootstrapRequest.node_peer)
}
#endif
inline void BootstrapRequest::set_node_peer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_node_peer();
  node_peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.BootstrapRequest.node_peer)
}
inline void BootstrapRequest::set_node_peer(const char* value, size_t size) {
  set_has_node_peer();
  node_peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.BootstrapRequest.node_peer)
}
inline ::std::string* BootstrapRequest::mutable_node_peer() {
  set_has_node_peer();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.BootstrapRequest.node_peer)
  return node_peer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapRequest::release_node_peer() {
  // @@protoc_insertion_point(field_release:elasticfaiss.BootstrapRequest.node_peer)
  if (!has_node_peer()) {
    return NULL;
  }
  clear_has_node_peer();
  return node_peer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapRequest::set_allocated_node_peer(::std::string* node_peer) {
  if (node_peer != NULL) {
    set_has_node_peer();
  } else {
    clear_has_node_peer();
  }
  node_peer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_peer);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.BootstrapRequest.node_peer)
}

// optional int64 boot_ms = 2;
inline bool BootstrapRequest::has_boot_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BootstrapRequest::set_has_boot_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BootstrapRequest::clear_has_boot_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BootstrapRequest::clear_boot_ms() {
  boot_ms_ = GOOGLE_LONGLONG(0);
  clear_has_boot_ms();
}
inline ::google::protobuf::int64 BootstrapRequest::boot_ms() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.BootstrapRequest.boot_ms)
  return boot_ms_;
}
inline void BootstrapRequest::set_boot_ms(::google::protobuf::int64 value) {
  set_has_boot_ms();
  boot_ms_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.BootstrapRequest.boot_ms)
}

// -------------------------------------------------------------------

// BootstrapResponse

// required bool success = 1;
inline bool BootstrapResponse::has_success() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BootstrapResponse::set_has_success() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BootstrapResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BootstrapResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool BootstrapResponse::success() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.BootstrapResponse.success)
  return success_;
}
inline void BootstrapResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.BootstrapResponse.success)
}

// optional string redirect = 2;
inline bool BootstrapResponse::has_redirect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BootstrapResponse::set_has_redirect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BootstrapResponse::clear_has_redirect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BootstrapResponse::clear_redirect() {
  redirect_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_redirect();
}
inline const ::std::string& BootstrapResponse::redirect() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.BootstrapResponse.redirect)
  return redirect_.GetNoArena();
}
inline void BootstrapResponse::set_redirect(const ::std::string& value) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.BootstrapResponse.redirect)
}
#if LANG_CXX11
inline void BootstrapResponse::set_redirect(::std::string&& value) {
  set_has_redirect();
  redirect_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.BootstrapResponse.redirect)
}
#endif
inline void BootstrapResponse::set_redirect(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.BootstrapResponse.redirect)
}
inline void BootstrapResponse::set_redirect(const char* value, size_t size) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.BootstrapResponse.redirect)
}
inline ::std::string* BootstrapResponse::mutable_redirect() {
  set_has_redirect();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.BootstrapResponse.redirect)
  return redirect_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BootstrapResponse::release_redirect() {
  // @@protoc_insertion_point(field_release:elasticfaiss.BootstrapResponse.redirect)
  if (!has_redirect()) {
    return NULL;
  }
  clear_has_redirect();
  return redirect_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BootstrapResponse::set_allocated_redirect(::std::string* redirect) {
  if (redirect != NULL) {
    set_has_redirect();
  } else {
    clear_has_redirect();
  }
  redirect_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), redirect);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.BootstrapResponse.redirect)
}

// repeated .elasticfaiss.WorkNode nodes = 3;
inline int BootstrapResponse::nodes_size() const {
  return nodes_.size();
}
inline void BootstrapResponse::clear_nodes() {
  nodes_.Clear();
}
inline ::elasticfaiss::WorkNode* BootstrapResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:elasticfaiss.BootstrapResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode >*
BootstrapResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:elasticfaiss.BootstrapResponse.nodes)
  return &nodes_;
}
inline const ::elasticfaiss::WorkNode& BootstrapResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:elasticfaiss.BootstrapResponse.nodes)
  return nodes_.Get(index);
}
inline ::elasticfaiss::WorkNode* BootstrapResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:elasticfaiss.BootstrapResponse.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode >&
BootstrapResponse::nodes() const {
  // @@protoc_insertion_point(field_list:elasticfaiss.BootstrapResponse.nodes)
  return nodes_;
}

// repeated .elasticfaiss.IndexShardConf shards = 4;
inline int BootstrapResponse::shards_size() const {
  return shards_.size();
}
inline ::elasticfaiss::IndexShardConf* BootstrapResponse::mutable_shards(int index) {
  // @@protoc_insertion_point(field_mutable:elasticfaiss.BootstrapResponse.shards)
  return shards_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::elasticfaiss::IndexShardConf >*
BootstrapResponse::mutable_shards() {
  // @@protoc_insertion_point(field_mutable_list:elasticfaiss.BootstrapResponse.shards)
  return &shards_;
}
inline const ::elasticfaiss::IndexShardConf& BootstrapResponse::shards(int index) const {
  // @@protoc_insertion_point(field_get:elasticfaiss.BootstrapResponse.shards)
  return shards_.Get(index);
}
inline ::elasticfaiss::IndexShardConf* BootstrapResponse::add_shards() {
  // @@protoc_insertion_point(field_add:elasticfaiss.BootstrapResponse.shards)
  return shards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::IndexShardConf >&
BootstrapResponse::shards() const {
  // @@protoc_insertion_point(field_list:elasticfaiss.BootstrapResponse.shards)
  return shards_;
}

// -------------------------------------------------------------------

// NodeHeartbeatRequest

// required string node_peer = 1;
inline bool NodeHeartbeatRequest::has_node_peer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeHeartbeatRequest::set_has_node_peer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeHeartbeatRequest::clear_has_node_peer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeHeartbeatRequest::clear_node_peer() {
  node_peer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_node_peer();
}
inline const ::std::string& NodeHeartbeatRequest::node_peer() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.NodeHeartbeatRequest.node_peer)
  return node_peer_.GetNoArena();
}
inline void NodeHeartbeatRequest::set_node_peer(const ::std::string& value) {
  set_has_node_peer();
  node_peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.NodeHeartbeatRequest.node_peer)
}
#if LANG_CXX11
inline void NodeHeartbeatRequest::set_node_peer(::std::string&& value) {
  set_has_node_peer();
  node_peer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.NodeHeartbeatRequest.node_peer)
}
#endif
inline void NodeHeartbeatRequest::set_node_peer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_node_peer();
  node_peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.NodeHeartbeatRequest.node_peer)
}
inline void NodeHeartbeatRequest::set_node_peer(const char* value, size_t size) {
  set_has_node_peer();
  node_peer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.NodeHeartbeatRequest.node_peer)
}
inline ::std::string* NodeHeartbeatRequest::mutable_node_peer() {
  set_has_node_peer();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.NodeHeartbeatRequest.node_peer)
  return node_peer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeHeartbeatRequest::release_node_peer() {
  // @@protoc_insertion_point(field_release:elasticfaiss.NodeHeartbeatRequest.node_peer)
  if (!has_node_peer()) {
    return NULL;
  }
  clear_has_node_peer();
  return node_peer_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeHeartbeatRequest::set_allocated_node_peer(::std::string* node_peer) {
  if (node_peer != NULL) {
    set_has_node_peer();
  } else {
    clear_has_node_peer();
  }
  node_peer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_peer);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.NodeHeartbeatRequest.node_peer)
}

// optional int64 active_ms = 2;
inline bool NodeHeartbeatRequest::has_active_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeHeartbeatRequest::set_has_active_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeHeartbeatRequest::clear_has_active_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeHeartbeatRequest::clear_active_ms() {
  active_ms_ = GOOGLE_LONGLONG(0);
  clear_has_active_ms();
}
inline ::google::protobuf::int64 NodeHeartbeatRequest::active_ms() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.NodeHeartbeatRequest.active_ms)
  return active_ms_;
}
inline void NodeHeartbeatRequest::set_active_ms(::google::protobuf::int64 value) {
  set_has_active_ms();
  active_ms_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.NodeHeartbeatRequest.active_ms)
}

// repeated .elasticfaiss.Shard shards = 3;
inline int NodeHeartbeatRequest::shards_size() const {
  return shards_.size();
}
inline ::elasticfaiss::Shard* NodeHeartbeatRequest::mutable_shards(int index) {
  // @@protoc_insertion_point(field_mutable:elasticfaiss.NodeHeartbeatRequest.shards)
  return shards_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard >*
NodeHeartbeatRequest::mutable_shards() {
  // @@protoc_insertion_point(field_mutable_list:elasticfaiss.NodeHeartbeatRequest.shards)
  return &shards_;
}
inline const ::elasticfaiss::Shard& NodeHeartbeatRequest::shards(int index) const {
  // @@protoc_insertion_point(field_get:elasticfaiss.NodeHeartbeatRequest.shards)
  return shards_.Get(index);
}
inline ::elasticfaiss::Shard* NodeHeartbeatRequest::add_shards() {
  // @@protoc_insertion_point(field_add:elasticfaiss.NodeHeartbeatRequest.shards)
  return shards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard >&
NodeHeartbeatRequest::shards() const {
  // @@protoc_insertion_point(field_list:elasticfaiss.NodeHeartbeatRequest.shards)
  return shards_;
}

// -------------------------------------------------------------------

// NodeHeartbeatResponse

// required bool success = 1;
inline bool NodeHeartbeatResponse::has_success() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeHeartbeatResponse::set_has_success() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeHeartbeatResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeHeartbeatResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool NodeHeartbeatResponse::success() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.NodeHeartbeatResponse.success)
  return success_;
}
inline void NodeHeartbeatResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.NodeHeartbeatResponse.success)
}

// optional string redirect = 2;
inline bool NodeHeartbeatResponse::has_redirect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeHeartbeatResponse::set_has_redirect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeHeartbeatResponse::clear_has_redirect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeHeartbeatResponse::clear_redirect() {
  redirect_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_redirect();
}
inline const ::std::string& NodeHeartbeatResponse::redirect() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.NodeHeartbeatResponse.redirect)
  return redirect_.GetNoArena();
}
inline void NodeHeartbeatResponse::set_redirect(const ::std::string& value) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.NodeHeartbeatResponse.redirect)
}
#if LANG_CXX11
inline void NodeHeartbeatResponse::set_redirect(::std::string&& value) {
  set_has_redirect();
  redirect_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.NodeHeartbeatResponse.redirect)
}
#endif
inline void NodeHeartbeatResponse::set_redirect(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.NodeHeartbeatResponse.redirect)
}
inline void NodeHeartbeatResponse::set_redirect(const char* value, size_t size) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.NodeHeartbeatResponse.redirect)
}
inline ::std::string* NodeHeartbeatResponse::mutable_redirect() {
  set_has_redirect();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.NodeHeartbeatResponse.redirect)
  return redirect_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeHeartbeatResponse::release_redirect() {
  // @@protoc_insertion_point(field_release:elasticfaiss.NodeHeartbeatResponse.redirect)
  if (!has_redirect()) {
    return NULL;
  }
  clear_has_redirect();
  return redirect_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeHeartbeatResponse::set_allocated_redirect(::std::string* redirect) {
  if (redirect != NULL) {
    set_has_redirect();
  } else {
    clear_has_redirect();
  }
  redirect_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), redirect);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.NodeHeartbeatResponse.redirect)
}

// repeated .elasticfaiss.WorkNode nodes = 3;
inline int NodeHeartbeatResponse::nodes_size() const {
  return nodes_.size();
}
inline void NodeHeartbeatResponse::clear_nodes() {
  nodes_.Clear();
}
inline ::elasticfaiss::WorkNode* NodeHeartbeatResponse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:elasticfaiss.NodeHeartbeatResponse.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode >*
NodeHeartbeatResponse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:elasticfaiss.NodeHeartbeatResponse.nodes)
  return &nodes_;
}
inline const ::elasticfaiss::WorkNode& NodeHeartbeatResponse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:elasticfaiss.NodeHeartbeatResponse.nodes)
  return nodes_.Get(index);
}
inline ::elasticfaiss::WorkNode* NodeHeartbeatResponse::add_nodes() {
  // @@protoc_insertion_point(field_add:elasticfaiss.NodeHeartbeatResponse.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::WorkNode >&
NodeHeartbeatResponse::nodes() const {
  // @@protoc_insertion_point(field_list:elasticfaiss.NodeHeartbeatResponse.nodes)
  return nodes_;
}

// -------------------------------------------------------------------

// GetClusterStateRequest

// required string cluster = 1;
inline bool GetClusterStateRequest::has_cluster() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClusterStateRequest::set_has_cluster() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClusterStateRequest::clear_has_cluster() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClusterStateRequest::clear_cluster() {
  cluster_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cluster();
}
inline const ::std::string& GetClusterStateRequest::cluster() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.GetClusterStateRequest.cluster)
  return cluster_.GetNoArena();
}
inline void GetClusterStateRequest::set_cluster(const ::std::string& value) {
  set_has_cluster();
  cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.GetClusterStateRequest.cluster)
}
#if LANG_CXX11
inline void GetClusterStateRequest::set_cluster(::std::string&& value) {
  set_has_cluster();
  cluster_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.GetClusterStateRequest.cluster)
}
#endif
inline void GetClusterStateRequest::set_cluster(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cluster();
  cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.GetClusterStateRequest.cluster)
}
inline void GetClusterStateRequest::set_cluster(const char* value, size_t size) {
  set_has_cluster();
  cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.GetClusterStateRequest.cluster)
}
inline ::std::string* GetClusterStateRequest::mutable_cluster() {
  set_has_cluster();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.GetClusterStateRequest.cluster)
  return cluster_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetClusterStateRequest::release_cluster() {
  // @@protoc_insertion_point(field_release:elasticfaiss.GetClusterStateRequest.cluster)
  if (!has_cluster()) {
    return NULL;
  }
  clear_has_cluster();
  return cluster_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetClusterStateRequest::set_allocated_cluster(::std::string* cluster) {
  if (cluster != NULL) {
    set_has_cluster();
  } else {
    clear_has_cluster();
  }
  cluster_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cluster);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.GetClusterStateRequest.cluster)
}

// -------------------------------------------------------------------

// GetClusterStateResponse

// required bool success = 1;
inline bool GetClusterStateResponse::has_success() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetClusterStateResponse::set_has_success() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetClusterStateResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetClusterStateResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool GetClusterStateResponse::success() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.GetClusterStateResponse.success)
  return success_;
}
inline void GetClusterStateResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.GetClusterStateResponse.success)
}

// optional string redirect = 2;
inline bool GetClusterStateResponse::has_redirect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetClusterStateResponse::set_has_redirect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetClusterStateResponse::clear_has_redirect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetClusterStateResponse::clear_redirect() {
  redirect_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_redirect();
}
inline const ::std::string& GetClusterStateResponse::redirect() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.GetClusterStateResponse.redirect)
  return redirect_.GetNoArena();
}
inline void GetClusterStateResponse::set_redirect(const ::std::string& value) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.GetClusterStateResponse.redirect)
}
#if LANG_CXX11
inline void GetClusterStateResponse::set_redirect(::std::string&& value) {
  set_has_redirect();
  redirect_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.GetClusterStateResponse.redirect)
}
#endif
inline void GetClusterStateResponse::set_redirect(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.GetClusterStateResponse.redirect)
}
inline void GetClusterStateResponse::set_redirect(const char* value, size_t size) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.GetClusterStateResponse.redirect)
}
inline ::std::string* GetClusterStateResponse::mutable_redirect() {
  set_has_redirect();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.GetClusterStateResponse.redirect)
  return redirect_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetClusterStateResponse::release_redirect() {
  // @@protoc_insertion_point(field_release:elasticfaiss.GetClusterStateResponse.redirect)
  if (!has_redirect()) {
    return NULL;
  }
  clear_has_redirect();
  return redirect_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetClusterStateResponse::set_allocated_redirect(::std::string* redirect) {
  if (redirect != NULL) {
    set_has_redirect();
  } else {
    clear_has_redirect();
  }
  redirect_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), redirect);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.GetClusterStateResponse.redirect)
}

// optional .elasticfaiss.ClusterState state = 3;
inline bool GetClusterStateResponse::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetClusterStateResponse::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetClusterStateResponse::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetClusterStateResponse::clear_state() {
  if (state_ != NULL) state_->Clear();
  clear_has_state();
}
inline const ::elasticfaiss::ClusterState& GetClusterStateResponse::_internal_state() const {
  return *state_;
}
inline const ::elasticfaiss::ClusterState& GetClusterStateResponse::state() const {
  const ::elasticfaiss::ClusterState* p = state_;
  // @@protoc_insertion_point(field_get:elasticfaiss.GetClusterStateResponse.state)
  return p != NULL ? *p : *reinterpret_cast<const ::elasticfaiss::ClusterState*>(
      &::elasticfaiss::_ClusterState_default_instance_);
}
inline ::elasticfaiss::ClusterState* GetClusterStateResponse::release_state() {
  // @@protoc_insertion_point(field_release:elasticfaiss.GetClusterStateResponse.state)
  clear_has_state();
  ::elasticfaiss::ClusterState* temp = state_;
  state_ = NULL;
  return temp;
}
inline ::elasticfaiss::ClusterState* GetClusterStateResponse::mutable_state() {
  set_has_state();
  if (state_ == NULL) {
    auto* p = CreateMaybeMessage<::elasticfaiss::ClusterState>(GetArenaNoVirtual());
    state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:elasticfaiss.GetClusterStateResponse.state)
  return state_;
}
inline void GetClusterStateResponse::set_allocated_state(::elasticfaiss::ClusterState* state) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_;
  }
  if (state) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    set_has_state();
  } else {
    clear_has_state();
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.GetClusterStateResponse.state)
}

// -------------------------------------------------------------------

// CreateIndexRequest

// required .elasticfaiss.IndexConf conf = 1;
inline bool CreateIndexRequest::has_conf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateIndexRequest::set_has_conf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateIndexRequest::clear_has_conf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::elasticfaiss::IndexConf& CreateIndexRequest::_internal_conf() const {
  return *conf_;
}
inline const ::elasticfaiss::IndexConf& CreateIndexRequest::conf() const {
  const ::elasticfaiss::IndexConf* p = conf_;
  // @@protoc_insertion_point(field_get:elasticfaiss.CreateIndexRequest.conf)
  return p != NULL ? *p : *reinterpret_cast<const ::elasticfaiss::IndexConf*>(
      &::elasticfaiss::_IndexConf_default_instance_);
}
inline ::elasticfaiss::IndexConf* CreateIndexRequest::release_conf() {
  // @@protoc_insertion_point(field_release:elasticfaiss.CreateIndexRequest.conf)
  clear_has_conf();
  ::elasticfaiss::IndexConf* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline ::elasticfaiss::IndexConf* CreateIndexRequest::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) {
    auto* p = CreateMaybeMessage<::elasticfaiss::IndexConf>(GetArenaNoVirtual());
    conf_ = p;
  }
  // @@protoc_insertion_point(field_mutable:elasticfaiss.CreateIndexRequest.conf)
  return conf_;
}
inline void CreateIndexRequest::set_allocated_conf(::elasticfaiss::IndexConf* conf) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(conf_);
  }
  if (conf) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      conf = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conf, submessage_arena);
    }
    set_has_conf();
  } else {
    clear_has_conf();
  }
  conf_ = conf;
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.CreateIndexRequest.conf)
}

// -------------------------------------------------------------------

// CreateIndexResponse

// required bool success = 1;
inline bool CreateIndexResponse::has_success() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateIndexResponse::set_has_success() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateIndexResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateIndexResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool CreateIndexResponse::success() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.CreateIndexResponse.success)
  return success_;
}
inline void CreateIndexResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.CreateIndexResponse.success)
}

// optional string redirect = 2;
inline bool CreateIndexResponse::has_redirect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateIndexResponse::set_has_redirect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateIndexResponse::clear_has_redirect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateIndexResponse::clear_redirect() {
  redirect_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_redirect();
}
inline const ::std::string& CreateIndexResponse::redirect() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.CreateIndexResponse.redirect)
  return redirect_.GetNoArena();
}
inline void CreateIndexResponse::set_redirect(const ::std::string& value) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.CreateIndexResponse.redirect)
}
#if LANG_CXX11
inline void CreateIndexResponse::set_redirect(::std::string&& value) {
  set_has_redirect();
  redirect_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.CreateIndexResponse.redirect)
}
#endif
inline void CreateIndexResponse::set_redirect(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.CreateIndexResponse.redirect)
}
inline void CreateIndexResponse::set_redirect(const char* value, size_t size) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.CreateIndexResponse.redirect)
}
inline ::std::string* CreateIndexResponse::mutable_redirect() {
  set_has_redirect();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.CreateIndexResponse.redirect)
  return redirect_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateIndexResponse::release_redirect() {
  // @@protoc_insertion_point(field_release:elasticfaiss.CreateIndexResponse.redirect)
  if (!has_redirect()) {
    return NULL;
  }
  clear_has_redirect();
  return redirect_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateIndexResponse::set_allocated_redirect(::std::string* redirect) {
  if (redirect != NULL) {
    set_has_redirect();
  } else {
    clear_has_redirect();
  }
  redirect_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), redirect);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.CreateIndexResponse.redirect)
}

// optional string error = 3;
inline bool CreateIndexResponse::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateIndexResponse::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateIndexResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateIndexResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& CreateIndexResponse::error() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.CreateIndexResponse.error)
  return error_.GetNoArena();
}
inline void CreateIndexResponse::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.CreateIndexResponse.error)
}
#if LANG_CXX11
inline void CreateIndexResponse::set_error(::std::string&& value) {
  set_has_error();
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.CreateIndexResponse.error)
}
#endif
inline void CreateIndexResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.CreateIndexResponse.error)
}
inline void CreateIndexResponse::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.CreateIndexResponse.error)
}
inline ::std::string* CreateIndexResponse::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.CreateIndexResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateIndexResponse::release_error() {
  // @@protoc_insertion_point(field_release:elasticfaiss.CreateIndexResponse.error)
  if (!has_error()) {
    return NULL;
  }
  clear_has_error();
  return error_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateIndexResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.CreateIndexResponse.error)
}

// -------------------------------------------------------------------

// DeleteIndexRequest

// required string index_name = 1;
inline bool DeleteIndexRequest::has_index_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteIndexRequest::set_has_index_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteIndexRequest::clear_has_index_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteIndexRequest::clear_index_name() {
  index_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_index_name();
}
inline const ::std::string& DeleteIndexRequest::index_name() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.DeleteIndexRequest.index_name)
  return index_name_.GetNoArena();
}
inline void DeleteIndexRequest::set_index_name(const ::std::string& value) {
  set_has_index_name();
  index_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.DeleteIndexRequest.index_name)
}
#if LANG_CXX11
inline void DeleteIndexRequest::set_index_name(::std::string&& value) {
  set_has_index_name();
  index_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.DeleteIndexRequest.index_name)
}
#endif
inline void DeleteIndexRequest::set_index_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_index_name();
  index_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.DeleteIndexRequest.index_name)
}
inline void DeleteIndexRequest::set_index_name(const char* value, size_t size) {
  set_has_index_name();
  index_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.DeleteIndexRequest.index_name)
}
inline ::std::string* DeleteIndexRequest::mutable_index_name() {
  set_has_index_name();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.DeleteIndexRequest.index_name)
  return index_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteIndexRequest::release_index_name() {
  // @@protoc_insertion_point(field_release:elasticfaiss.DeleteIndexRequest.index_name)
  if (!has_index_name()) {
    return NULL;
  }
  clear_has_index_name();
  return index_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteIndexRequest::set_allocated_index_name(::std::string* index_name) {
  if (index_name != NULL) {
    set_has_index_name();
  } else {
    clear_has_index_name();
  }
  index_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), index_name);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.DeleteIndexRequest.index_name)
}

// -------------------------------------------------------------------

// DeleteIndexResponse

// required bool success = 1;
inline bool DeleteIndexResponse::has_success() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeleteIndexResponse::set_has_success() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeleteIndexResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeleteIndexResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool DeleteIndexResponse::success() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.DeleteIndexResponse.success)
  return success_;
}
inline void DeleteIndexResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.DeleteIndexResponse.success)
}

// optional string redirect = 2;
inline bool DeleteIndexResponse::has_redirect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteIndexResponse::set_has_redirect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteIndexResponse::clear_has_redirect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteIndexResponse::clear_redirect() {
  redirect_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_redirect();
}
inline const ::std::string& DeleteIndexResponse::redirect() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.DeleteIndexResponse.redirect)
  return redirect_.GetNoArena();
}
inline void DeleteIndexResponse::set_redirect(const ::std::string& value) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.DeleteIndexResponse.redirect)
}
#if LANG_CXX11
inline void DeleteIndexResponse::set_redirect(::std::string&& value) {
  set_has_redirect();
  redirect_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.DeleteIndexResponse.redirect)
}
#endif
inline void DeleteIndexResponse::set_redirect(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.DeleteIndexResponse.redirect)
}
inline void DeleteIndexResponse::set_redirect(const char* value, size_t size) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.DeleteIndexResponse.redirect)
}
inline ::std::string* DeleteIndexResponse::mutable_redirect() {
  set_has_redirect();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.DeleteIndexResponse.redirect)
  return redirect_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteIndexResponse::release_redirect() {
  // @@protoc_insertion_point(field_release:elasticfaiss.DeleteIndexResponse.redirect)
  if (!has_redirect()) {
    return NULL;
  }
  clear_has_redirect();
  return redirect_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteIndexResponse::set_allocated_redirect(::std::string* redirect) {
  if (redirect != NULL) {
    set_has_redirect();
  } else {
    clear_has_redirect();
  }
  redirect_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), redirect);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.DeleteIndexResponse.redirect)
}

// optional string error = 3;
inline bool DeleteIndexResponse::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteIndexResponse::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteIndexResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteIndexResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& DeleteIndexResponse::error() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.DeleteIndexResponse.error)
  return error_.GetNoArena();
}
inline void DeleteIndexResponse::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.DeleteIndexResponse.error)
}
#if LANG_CXX11
inline void DeleteIndexResponse::set_error(::std::string&& value) {
  set_has_error();
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.DeleteIndexResponse.error)
}
#endif
inline void DeleteIndexResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.DeleteIndexResponse.error)
}
inline void DeleteIndexResponse::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.DeleteIndexResponse.error)
}
inline ::std::string* DeleteIndexResponse::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.DeleteIndexResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteIndexResponse::release_error() {
  // @@protoc_insertion_point(field_release:elasticfaiss.DeleteIndexResponse.error)
  if (!has_error()) {
    return NULL;
  }
  clear_has_error();
  return error_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteIndexResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.DeleteIndexResponse.error)
}

// -------------------------------------------------------------------

// UpdateIndexRequest

// required .elasticfaiss.IndexConf conf = 1;
inline bool UpdateIndexRequest::has_conf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateIndexRequest::set_has_conf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateIndexRequest::clear_has_conf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::elasticfaiss::IndexConf& UpdateIndexRequest::_internal_conf() const {
  return *conf_;
}
inline const ::elasticfaiss::IndexConf& UpdateIndexRequest::conf() const {
  const ::elasticfaiss::IndexConf* p = conf_;
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateIndexRequest.conf)
  return p != NULL ? *p : *reinterpret_cast<const ::elasticfaiss::IndexConf*>(
      &::elasticfaiss::_IndexConf_default_instance_);
}
inline ::elasticfaiss::IndexConf* UpdateIndexRequest::release_conf() {
  // @@protoc_insertion_point(field_release:elasticfaiss.UpdateIndexRequest.conf)
  clear_has_conf();
  ::elasticfaiss::IndexConf* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline ::elasticfaiss::IndexConf* UpdateIndexRequest::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) {
    auto* p = CreateMaybeMessage<::elasticfaiss::IndexConf>(GetArenaNoVirtual());
    conf_ = p;
  }
  // @@protoc_insertion_point(field_mutable:elasticfaiss.UpdateIndexRequest.conf)
  return conf_;
}
inline void UpdateIndexRequest::set_allocated_conf(::elasticfaiss::IndexConf* conf) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(conf_);
  }
  if (conf) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      conf = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conf, submessage_arena);
    }
    set_has_conf();
  } else {
    clear_has_conf();
  }
  conf_ = conf;
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.UpdateIndexRequest.conf)
}

// -------------------------------------------------------------------

// UpdateIndexResponse

// required bool success = 1;
inline bool UpdateIndexResponse::has_success() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateIndexResponse::set_has_success() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateIndexResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateIndexResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool UpdateIndexResponse::success() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateIndexResponse.success)
  return success_;
}
inline void UpdateIndexResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.UpdateIndexResponse.success)
}

// optional string redirect = 2;
inline bool UpdateIndexResponse::has_redirect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateIndexResponse::set_has_redirect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateIndexResponse::clear_has_redirect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateIndexResponse::clear_redirect() {
  redirect_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_redirect();
}
inline const ::std::string& UpdateIndexResponse::redirect() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateIndexResponse.redirect)
  return redirect_.GetNoArena();
}
inline void UpdateIndexResponse::set_redirect(const ::std::string& value) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.UpdateIndexResponse.redirect)
}
#if LANG_CXX11
inline void UpdateIndexResponse::set_redirect(::std::string&& value) {
  set_has_redirect();
  redirect_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.UpdateIndexResponse.redirect)
}
#endif
inline void UpdateIndexResponse::set_redirect(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.UpdateIndexResponse.redirect)
}
inline void UpdateIndexResponse::set_redirect(const char* value, size_t size) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.UpdateIndexResponse.redirect)
}
inline ::std::string* UpdateIndexResponse::mutable_redirect() {
  set_has_redirect();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.UpdateIndexResponse.redirect)
  return redirect_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateIndexResponse::release_redirect() {
  // @@protoc_insertion_point(field_release:elasticfaiss.UpdateIndexResponse.redirect)
  if (!has_redirect()) {
    return NULL;
  }
  clear_has_redirect();
  return redirect_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateIndexResponse::set_allocated_redirect(::std::string* redirect) {
  if (redirect != NULL) {
    set_has_redirect();
  } else {
    clear_has_redirect();
  }
  redirect_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), redirect);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.UpdateIndexResponse.redirect)
}

// optional string error = 3;
inline bool UpdateIndexResponse::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateIndexResponse::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateIndexResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateIndexResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& UpdateIndexResponse::error() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateIndexResponse.error)
  return error_.GetNoArena();
}
inline void UpdateIndexResponse::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.UpdateIndexResponse.error)
}
#if LANG_CXX11
inline void UpdateIndexResponse::set_error(::std::string&& value) {
  set_has_error();
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.UpdateIndexResponse.error)
}
#endif
inline void UpdateIndexResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.UpdateIndexResponse.error)
}
inline void UpdateIndexResponse::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.UpdateIndexResponse.error)
}
inline ::std::string* UpdateIndexResponse::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.UpdateIndexResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateIndexResponse::release_error() {
  // @@protoc_insertion_point(field_release:elasticfaiss.UpdateIndexResponse.error)
  if (!has_error()) {
    return NULL;
  }
  clear_has_error();
  return error_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateIndexResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.UpdateIndexResponse.error)
}

// -------------------------------------------------------------------

// UpdateNodeRequest

// required string peer_id = 1;
inline bool UpdateNodeRequest::has_peer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateNodeRequest::set_has_peer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateNodeRequest::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateNodeRequest::clear_peer_id() {
  peer_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer_id();
}
inline const ::std::string& UpdateNodeRequest::peer_id() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateNodeRequest.peer_id)
  return peer_id_.GetNoArena();
}
inline void UpdateNodeRequest::set_peer_id(const ::std::string& value) {
  set_has_peer_id();
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.UpdateNodeRequest.peer_id)
}
#if LANG_CXX11
inline void UpdateNodeRequest::set_peer_id(::std::string&& value) {
  set_has_peer_id();
  peer_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.UpdateNodeRequest.peer_id)
}
#endif
inline void UpdateNodeRequest::set_peer_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer_id();
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.UpdateNodeRequest.peer_id)
}
inline void UpdateNodeRequest::set_peer_id(const char* value, size_t size) {
  set_has_peer_id();
  peer_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.UpdateNodeRequest.peer_id)
}
inline ::std::string* UpdateNodeRequest::mutable_peer_id() {
  set_has_peer_id();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.UpdateNodeRequest.peer_id)
  return peer_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateNodeRequest::release_peer_id() {
  // @@protoc_insertion_point(field_release:elasticfaiss.UpdateNodeRequest.peer_id)
  if (!has_peer_id()) {
    return NULL;
  }
  clear_has_peer_id();
  return peer_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateNodeRequest::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id != NULL) {
    set_has_peer_id();
  } else {
    clear_has_peer_id();
  }
  peer_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_id);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.UpdateNodeRequest.peer_id)
}

// optional int32 state = 2;
inline bool UpdateNodeRequest::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateNodeRequest::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateNodeRequest::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateNodeRequest::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 UpdateNodeRequest::state() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateNodeRequest.state)
  return state_;
}
inline void UpdateNodeRequest::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.UpdateNodeRequest.state)
}

// required int64 state_ms = 3;
inline bool UpdateNodeRequest::has_state_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateNodeRequest::set_has_state_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateNodeRequest::clear_has_state_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateNodeRequest::clear_state_ms() {
  state_ms_ = GOOGLE_LONGLONG(0);
  clear_has_state_ms();
}
inline ::google::protobuf::int64 UpdateNodeRequest::state_ms() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateNodeRequest.state_ms)
  return state_ms_;
}
inline void UpdateNodeRequest::set_state_ms(::google::protobuf::int64 value) {
  set_has_state_ms();
  state_ms_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.UpdateNodeRequest.state_ms)
}

// repeated .elasticfaiss.Shard shards = 4;
inline int UpdateNodeRequest::shards_size() const {
  return shards_.size();
}
inline ::elasticfaiss::Shard* UpdateNodeRequest::mutable_shards(int index) {
  // @@protoc_insertion_point(field_mutable:elasticfaiss.UpdateNodeRequest.shards)
  return shards_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard >*
UpdateNodeRequest::mutable_shards() {
  // @@protoc_insertion_point(field_mutable_list:elasticfaiss.UpdateNodeRequest.shards)
  return &shards_;
}
inline const ::elasticfaiss::Shard& UpdateNodeRequest::shards(int index) const {
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateNodeRequest.shards)
  return shards_.Get(index);
}
inline ::elasticfaiss::Shard* UpdateNodeRequest::add_shards() {
  // @@protoc_insertion_point(field_add:elasticfaiss.UpdateNodeRequest.shards)
  return shards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::elasticfaiss::Shard >&
UpdateNodeRequest::shards() const {
  // @@protoc_insertion_point(field_list:elasticfaiss.UpdateNodeRequest.shards)
  return shards_;
}

// -------------------------------------------------------------------

// UpdateNodeResponse

// required bool success = 1;
inline bool UpdateNodeResponse::has_success() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateNodeResponse::set_has_success() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateNodeResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateNodeResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool UpdateNodeResponse::success() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateNodeResponse.success)
  return success_;
}
inline void UpdateNodeResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.UpdateNodeResponse.success)
}

// optional string redirect = 2;
inline bool UpdateNodeResponse::has_redirect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateNodeResponse::set_has_redirect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateNodeResponse::clear_has_redirect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateNodeResponse::clear_redirect() {
  redirect_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_redirect();
}
inline const ::std::string& UpdateNodeResponse::redirect() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateNodeResponse.redirect)
  return redirect_.GetNoArena();
}
inline void UpdateNodeResponse::set_redirect(const ::std::string& value) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.UpdateNodeResponse.redirect)
}
#if LANG_CXX11
inline void UpdateNodeResponse::set_redirect(::std::string&& value) {
  set_has_redirect();
  redirect_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.UpdateNodeResponse.redirect)
}
#endif
inline void UpdateNodeResponse::set_redirect(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.UpdateNodeResponse.redirect)
}
inline void UpdateNodeResponse::set_redirect(const char* value, size_t size) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.UpdateNodeResponse.redirect)
}
inline ::std::string* UpdateNodeResponse::mutable_redirect() {
  set_has_redirect();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.UpdateNodeResponse.redirect)
  return redirect_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateNodeResponse::release_redirect() {
  // @@protoc_insertion_point(field_release:elasticfaiss.UpdateNodeResponse.redirect)
  if (!has_redirect()) {
    return NULL;
  }
  clear_has_redirect();
  return redirect_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateNodeResponse::set_allocated_redirect(::std::string* redirect) {
  if (redirect != NULL) {
    set_has_redirect();
  } else {
    clear_has_redirect();
  }
  redirect_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), redirect);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.UpdateNodeResponse.redirect)
}

// optional string error = 3;
inline bool UpdateNodeResponse::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateNodeResponse::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateNodeResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateNodeResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& UpdateNodeResponse::error() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateNodeResponse.error)
  return error_.GetNoArena();
}
inline void UpdateNodeResponse::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.UpdateNodeResponse.error)
}
#if LANG_CXX11
inline void UpdateNodeResponse::set_error(::std::string&& value) {
  set_has_error();
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.UpdateNodeResponse.error)
}
#endif
inline void UpdateNodeResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.UpdateNodeResponse.error)
}
inline void UpdateNodeResponse::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.UpdateNodeResponse.error)
}
inline ::std::string* UpdateNodeResponse::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.UpdateNodeResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateNodeResponse::release_error() {
  // @@protoc_insertion_point(field_release:elasticfaiss.UpdateNodeResponse.error)
  if (!has_error()) {
    return NULL;
  }
  clear_has_error();
  return error_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateNodeResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.UpdateNodeResponse.error)
}

// -------------------------------------------------------------------

// UpdateClusterSettingRequest

// required .elasticfaiss.ClusterSettings settings = 1;
inline bool UpdateClusterSettingRequest::has_settings() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateClusterSettingRequest::set_has_settings() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateClusterSettingRequest::clear_has_settings() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateClusterSettingRequest::clear_settings() {
  if (settings_ != NULL) settings_->Clear();
  clear_has_settings();
}
inline const ::elasticfaiss::ClusterSettings& UpdateClusterSettingRequest::_internal_settings() const {
  return *settings_;
}
inline const ::elasticfaiss::ClusterSettings& UpdateClusterSettingRequest::settings() const {
  const ::elasticfaiss::ClusterSettings* p = settings_;
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateClusterSettingRequest.settings)
  return p != NULL ? *p : *reinterpret_cast<const ::elasticfaiss::ClusterSettings*>(
      &::elasticfaiss::_ClusterSettings_default_instance_);
}
inline ::elasticfaiss::ClusterSettings* UpdateClusterSettingRequest::release_settings() {
  // @@protoc_insertion_point(field_release:elasticfaiss.UpdateClusterSettingRequest.settings)
  clear_has_settings();
  ::elasticfaiss::ClusterSettings* temp = settings_;
  settings_ = NULL;
  return temp;
}
inline ::elasticfaiss::ClusterSettings* UpdateClusterSettingRequest::mutable_settings() {
  set_has_settings();
  if (settings_ == NULL) {
    auto* p = CreateMaybeMessage<::elasticfaiss::ClusterSettings>(GetArenaNoVirtual());
    settings_ = p;
  }
  // @@protoc_insertion_point(field_mutable:elasticfaiss.UpdateClusterSettingRequest.settings)
  return settings_;
}
inline void UpdateClusterSettingRequest::set_allocated_settings(::elasticfaiss::ClusterSettings* settings) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete settings_;
  }
  if (settings) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      settings = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    set_has_settings();
  } else {
    clear_has_settings();
  }
  settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.UpdateClusterSettingRequest.settings)
}

// -------------------------------------------------------------------

// UpdateClusterSettingResponse

// required bool success = 1;
inline bool UpdateClusterSettingResponse::has_success() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateClusterSettingResponse::set_has_success() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateClusterSettingResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateClusterSettingResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool UpdateClusterSettingResponse::success() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateClusterSettingResponse.success)
  return success_;
}
inline void UpdateClusterSettingResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.UpdateClusterSettingResponse.success)
}

// optional string redirect = 2;
inline bool UpdateClusterSettingResponse::has_redirect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateClusterSettingResponse::set_has_redirect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateClusterSettingResponse::clear_has_redirect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateClusterSettingResponse::clear_redirect() {
  redirect_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_redirect();
}
inline const ::std::string& UpdateClusterSettingResponse::redirect() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateClusterSettingResponse.redirect)
  return redirect_.GetNoArena();
}
inline void UpdateClusterSettingResponse::set_redirect(const ::std::string& value) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.UpdateClusterSettingResponse.redirect)
}
#if LANG_CXX11
inline void UpdateClusterSettingResponse::set_redirect(::std::string&& value) {
  set_has_redirect();
  redirect_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.UpdateClusterSettingResponse.redirect)
}
#endif
inline void UpdateClusterSettingResponse::set_redirect(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.UpdateClusterSettingResponse.redirect)
}
inline void UpdateClusterSettingResponse::set_redirect(const char* value, size_t size) {
  set_has_redirect();
  redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.UpdateClusterSettingResponse.redirect)
}
inline ::std::string* UpdateClusterSettingResponse::mutable_redirect() {
  set_has_redirect();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.UpdateClusterSettingResponse.redirect)
  return redirect_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateClusterSettingResponse::release_redirect() {
  // @@protoc_insertion_point(field_release:elasticfaiss.UpdateClusterSettingResponse.redirect)
  if (!has_redirect()) {
    return NULL;
  }
  clear_has_redirect();
  return redirect_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateClusterSettingResponse::set_allocated_redirect(::std::string* redirect) {
  if (redirect != NULL) {
    set_has_redirect();
  } else {
    clear_has_redirect();
  }
  redirect_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), redirect);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.UpdateClusterSettingResponse.redirect)
}

// optional string error = 3;
inline bool UpdateClusterSettingResponse::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateClusterSettingResponse::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateClusterSettingResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateClusterSettingResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& UpdateClusterSettingResponse::error() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.UpdateClusterSettingResponse.error)
  return error_.GetNoArena();
}
inline void UpdateClusterSettingResponse::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.UpdateClusterSettingResponse.error)
}
#if LANG_CXX11
inline void UpdateClusterSettingResponse::set_error(::std::string&& value) {
  set_has_error();
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.UpdateClusterSettingResponse.error)
}
#endif
inline void UpdateClusterSettingResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.UpdateClusterSettingResponse.error)
}
inline void UpdateClusterSettingResponse::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.UpdateClusterSettingResponse.error)
}
inline ::std::string* UpdateClusterSettingResponse::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.UpdateClusterSettingResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateClusterSettingResponse::release_error() {
  // @@protoc_insertion_point(field_release:elasticfaiss.UpdateClusterSettingResponse.error)
  if (!has_error()) {
    return NULL;
  }
  clear_has_error();
  return error_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateClusterSettingResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.UpdateClusterSettingResponse.error)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace elasticfaiss

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::elasticfaiss::WorkNodeState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::elasticfaiss::WorkNodeState>() {
  return ::elasticfaiss::WorkNodeState_descriptor();
}
template <> struct is_proto_enum< ::elasticfaiss::NodeRole> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::elasticfaiss::NodeRole>() {
  return ::elasticfaiss::NodeRole_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_master_2eproto
