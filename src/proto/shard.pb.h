// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: shard.proto

#ifndef PROTOBUF_INCLUDED_shard_2eproto
#define PROTOBUF_INCLUDED_shard_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_shard_2eproto 

namespace protobuf_shard_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_shard_2eproto
namespace elasticfaiss {
class IndexConf;
class IndexConfDefaultTypeInternal;
extern IndexConfDefaultTypeInternal _IndexConf_default_instance_;
class IndexShardConf;
class IndexShardConfDefaultTypeInternal;
extern IndexShardConfDefaultTypeInternal _IndexShardConf_default_instance_;
class Shard;
class ShardDefaultTypeInternal;
extern ShardDefaultTypeInternal _Shard_default_instance_;
}  // namespace elasticfaiss
namespace google {
namespace protobuf {
template<> ::elasticfaiss::IndexConf* Arena::CreateMaybeMessage<::elasticfaiss::IndexConf>(Arena*);
template<> ::elasticfaiss::IndexShardConf* Arena::CreateMaybeMessage<::elasticfaiss::IndexShardConf>(Arena*);
template<> ::elasticfaiss::Shard* Arena::CreateMaybeMessage<::elasticfaiss::Shard>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace elasticfaiss {

enum ShardState {
  SHARD_LOADING = 1,
  SHARD_ACTIVE = 2
};
bool ShardState_IsValid(int value);
const ShardState ShardState_MIN = SHARD_LOADING;
const ShardState ShardState_MAX = SHARD_ACTIVE;
const int ShardState_ARRAYSIZE = ShardState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ShardState_descriptor();
inline const ::std::string& ShardState_Name(ShardState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ShardState_descriptor(), value);
}
inline bool ShardState_Parse(
    const ::std::string& name, ShardState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ShardState>(
    ShardState_descriptor(), name, value);
}
// ===================================================================

class Shard : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.Shard) */ {
 public:
  Shard();
  virtual ~Shard();

  Shard(const Shard& from);

  inline Shard& operator=(const Shard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Shard(Shard&& from) noexcept
    : Shard() {
    *this = ::std::move(from);
  }

  inline Shard& operator=(Shard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Shard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Shard* internal_default_instance() {
    return reinterpret_cast<const Shard*>(
               &_Shard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Shard* other);
  friend void swap(Shard& a, Shard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Shard* New() const final {
    return CreateMaybeMessage<Shard>(NULL);
  }

  Shard* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Shard>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Shard& from);
  void MergeFrom(const Shard& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string nodes = 5;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 5;
  const ::std::string& nodes(int index) const;
  ::std::string* mutable_nodes(int index);
  void set_nodes(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_nodes(int index, ::std::string&& value);
  #endif
  void set_nodes(int index, const char* value);
  void set_nodes(int index, const char* value, size_t size);
  ::std::string* add_nodes();
  void add_nodes(const ::std::string& value);
  #if LANG_CXX11
  void add_nodes(::std::string&& value);
  #endif
  void add_nodes(const char* value);
  void add_nodes(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& nodes() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nodes();

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required int32 idx = 2;
  bool has_idx() const;
  void clear_idx();
  static const int kIdxFieldNumber = 2;
  ::google::protobuf::int32 idx() const;
  void set_idx(::google::protobuf::int32 value);

  // optional bool is_leader = 3;
  bool has_is_leader() const;
  void clear_is_leader();
  static const int kIsLeaderFieldNumber = 3;
  bool is_leader() const;
  void set_is_leader(bool value);

  // required int32 state = 4;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 4;
  ::google::protobuf::int32 state() const;
  void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.Shard)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_idx();
  void clear_has_idx();
  void set_has_is_leader();
  void clear_has_is_leader();
  void set_has_state();
  void clear_has_state();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nodes_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 idx_;
  bool is_leader_;
  ::google::protobuf::int32 state_;
  friend struct ::protobuf_shard_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IndexConf : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.IndexConf) */ {
 public:
  IndexConf();
  virtual ~IndexConf();

  IndexConf(const IndexConf& from);

  inline IndexConf& operator=(const IndexConf& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IndexConf(IndexConf&& from) noexcept
    : IndexConf() {
    *this = ::std::move(from);
  }

  inline IndexConf& operator=(IndexConf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexConf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndexConf* internal_default_instance() {
    return reinterpret_cast<const IndexConf*>(
               &_IndexConf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(IndexConf* other);
  friend void swap(IndexConf& a, IndexConf& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IndexConf* New() const final {
    return CreateMaybeMessage<IndexConf>(NULL);
  }

  IndexConf* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IndexConf>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IndexConf& from);
  void MergeFrom(const IndexConf& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexConf* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // required int32 number_of_shards = 3;
  bool has_number_of_shards() const;
  void clear_number_of_shards();
  static const int kNumberOfShardsFieldNumber = 3;
  ::google::protobuf::int32 number_of_shards() const;
  void set_number_of_shards(::google::protobuf::int32 value);

  // required int32 number_of_replicas = 4;
  bool has_number_of_replicas() const;
  void clear_number_of_replicas();
  static const int kNumberOfReplicasFieldNumber = 4;
  ::google::protobuf::int32 number_of_replicas() const;
  void set_number_of_replicas(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.IndexConf)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_number_of_shards();
  void clear_has_number_of_shards();
  void set_has_number_of_replicas();
  void clear_has_number_of_replicas();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::int32 number_of_shards_;
  ::google::protobuf::int32 number_of_replicas_;
  friend struct ::protobuf_shard_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IndexShardConf : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:elasticfaiss.IndexShardConf) */ {
 public:
  IndexShardConf();
  virtual ~IndexShardConf();

  IndexShardConf(const IndexShardConf& from);

  inline IndexShardConf& operator=(const IndexShardConf& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IndexShardConf(IndexShardConf&& from) noexcept
    : IndexShardConf() {
    *this = ::std::move(from);
  }

  inline IndexShardConf& operator=(IndexShardConf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexShardConf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndexShardConf* internal_default_instance() {
    return reinterpret_cast<const IndexShardConf*>(
               &_IndexShardConf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(IndexShardConf* other);
  friend void swap(IndexShardConf& a, IndexShardConf& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IndexShardConf* New() const final {
    return CreateMaybeMessage<IndexShardConf>(NULL);
  }

  IndexShardConf* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IndexShardConf>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IndexShardConf& from);
  void MergeFrom(const IndexShardConf& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexShardConf* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string nodes = 3;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 3;
  const ::std::string& nodes(int index) const;
  ::std::string* mutable_nodes(int index);
  void set_nodes(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_nodes(int index, ::std::string&& value);
  #endif
  void set_nodes(int index, const char* value);
  void set_nodes(int index, const char* value, size_t size);
  ::std::string* add_nodes();
  void add_nodes(const ::std::string& value);
  #if LANG_CXX11
  void add_nodes(::std::string&& value);
  #endif
  void add_nodes(const char* value);
  void add_nodes(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& nodes() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nodes();

  // required .elasticfaiss.IndexConf conf = 1;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 1;
  private:
  const ::elasticfaiss::IndexConf& _internal_conf() const;
  public:
  const ::elasticfaiss::IndexConf& conf() const;
  ::elasticfaiss::IndexConf* release_conf();
  ::elasticfaiss::IndexConf* mutable_conf();
  void set_allocated_conf(::elasticfaiss::IndexConf* conf);

  // required int32 shard_idx = 2;
  bool has_shard_idx() const;
  void clear_shard_idx();
  static const int kShardIdxFieldNumber = 2;
  ::google::protobuf::int32 shard_idx() const;
  void set_shard_idx(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:elasticfaiss.IndexShardConf)
 private:
  void set_has_conf();
  void clear_has_conf();
  void set_has_shard_idx();
  void clear_has_shard_idx();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nodes_;
  ::elasticfaiss::IndexConf* conf_;
  ::google::protobuf::int32 shard_idx_;
  friend struct ::protobuf_shard_2eproto::TableStruct;
};
// ===================================================================

class ShardService_Stub;

class ShardService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline ShardService() {};
 public:
  virtual ~ShardService();

  typedef ShardService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();


  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ShardService);
};

class ShardService_Stub : public ShardService {
 public:
  ShardService_Stub(::google::protobuf::RpcChannel* channel);
  ShardService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~ShardService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements ShardService ------------------------------------------

 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(ShardService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Shard

// required string name = 1;
inline bool Shard::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Shard::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Shard::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Shard::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Shard::name() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.Shard.name)
  return name_.GetNoArena();
}
inline void Shard::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.Shard.name)
}
#if LANG_CXX11
inline void Shard::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.Shard.name)
}
#endif
inline void Shard::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.Shard.name)
}
inline void Shard::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.Shard.name)
}
inline ::std::string* Shard::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.Shard.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Shard::release_name() {
  // @@protoc_insertion_point(field_release:elasticfaiss.Shard.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Shard::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.Shard.name)
}

// required int32 idx = 2;
inline bool Shard::has_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Shard::set_has_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Shard::clear_has_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Shard::clear_idx() {
  idx_ = 0;
  clear_has_idx();
}
inline ::google::protobuf::int32 Shard::idx() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.Shard.idx)
  return idx_;
}
inline void Shard::set_idx(::google::protobuf::int32 value) {
  set_has_idx();
  idx_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.Shard.idx)
}

// optional bool is_leader = 3;
inline bool Shard::has_is_leader() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Shard::set_has_is_leader() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Shard::clear_has_is_leader() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Shard::clear_is_leader() {
  is_leader_ = false;
  clear_has_is_leader();
}
inline bool Shard::is_leader() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.Shard.is_leader)
  return is_leader_;
}
inline void Shard::set_is_leader(bool value) {
  set_has_is_leader();
  is_leader_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.Shard.is_leader)
}

// required int32 state = 4;
inline bool Shard::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Shard::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Shard::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Shard::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 Shard::state() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.Shard.state)
  return state_;
}
inline void Shard::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.Shard.state)
}

// repeated string nodes = 5;
inline int Shard::nodes_size() const {
  return nodes_.size();
}
inline void Shard::clear_nodes() {
  nodes_.Clear();
}
inline const ::std::string& Shard::nodes(int index) const {
  // @@protoc_insertion_point(field_get:elasticfaiss.Shard.nodes)
  return nodes_.Get(index);
}
inline ::std::string* Shard::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:elasticfaiss.Shard.nodes)
  return nodes_.Mutable(index);
}
inline void Shard::set_nodes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:elasticfaiss.Shard.nodes)
  nodes_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Shard::set_nodes(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:elasticfaiss.Shard.nodes)
  nodes_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Shard::set_nodes(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:elasticfaiss.Shard.nodes)
}
inline void Shard::set_nodes(int index, const char* value, size_t size) {
  nodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.Shard.nodes)
}
inline ::std::string* Shard::add_nodes() {
  // @@protoc_insertion_point(field_add_mutable:elasticfaiss.Shard.nodes)
  return nodes_.Add();
}
inline void Shard::add_nodes(const ::std::string& value) {
  nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:elasticfaiss.Shard.nodes)
}
#if LANG_CXX11
inline void Shard::add_nodes(::std::string&& value) {
  nodes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:elasticfaiss.Shard.nodes)
}
#endif
inline void Shard::add_nodes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:elasticfaiss.Shard.nodes)
}
inline void Shard::add_nodes(const char* value, size_t size) {
  nodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:elasticfaiss.Shard.nodes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Shard::nodes() const {
  // @@protoc_insertion_point(field_list:elasticfaiss.Shard.nodes)
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Shard::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:elasticfaiss.Shard.nodes)
  return &nodes_;
}

// -------------------------------------------------------------------

// IndexConf

// required string name = 1;
inline bool IndexConf::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IndexConf::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IndexConf::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IndexConf::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& IndexConf::name() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.IndexConf.name)
  return name_.GetNoArena();
}
inline void IndexConf::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.IndexConf.name)
}
#if LANG_CXX11
inline void IndexConf::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.IndexConf.name)
}
#endif
inline void IndexConf::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.IndexConf.name)
}
inline void IndexConf::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.IndexConf.name)
}
inline ::std::string* IndexConf::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.IndexConf.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IndexConf::release_name() {
  // @@protoc_insertion_point(field_release:elasticfaiss.IndexConf.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IndexConf::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.IndexConf.name)
}

// required string type = 2;
inline bool IndexConf::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IndexConf::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IndexConf::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IndexConf::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& IndexConf::type() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.IndexConf.type)
  return type_.GetNoArena();
}
inline void IndexConf::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:elasticfaiss.IndexConf.type)
}
#if LANG_CXX11
inline void IndexConf::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:elasticfaiss.IndexConf.type)
}
#endif
inline void IndexConf::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:elasticfaiss.IndexConf.type)
}
inline void IndexConf::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.IndexConf.type)
}
inline ::std::string* IndexConf::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:elasticfaiss.IndexConf.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IndexConf::release_type() {
  // @@protoc_insertion_point(field_release:elasticfaiss.IndexConf.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IndexConf::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.IndexConf.type)
}

// required int32 number_of_shards = 3;
inline bool IndexConf::has_number_of_shards() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IndexConf::set_has_number_of_shards() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IndexConf::clear_has_number_of_shards() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IndexConf::clear_number_of_shards() {
  number_of_shards_ = 0;
  clear_has_number_of_shards();
}
inline ::google::protobuf::int32 IndexConf::number_of_shards() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.IndexConf.number_of_shards)
  return number_of_shards_;
}
inline void IndexConf::set_number_of_shards(::google::protobuf::int32 value) {
  set_has_number_of_shards();
  number_of_shards_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.IndexConf.number_of_shards)
}

// required int32 number_of_replicas = 4;
inline bool IndexConf::has_number_of_replicas() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IndexConf::set_has_number_of_replicas() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IndexConf::clear_has_number_of_replicas() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IndexConf::clear_number_of_replicas() {
  number_of_replicas_ = 0;
  clear_has_number_of_replicas();
}
inline ::google::protobuf::int32 IndexConf::number_of_replicas() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.IndexConf.number_of_replicas)
  return number_of_replicas_;
}
inline void IndexConf::set_number_of_replicas(::google::protobuf::int32 value) {
  set_has_number_of_replicas();
  number_of_replicas_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.IndexConf.number_of_replicas)
}

// -------------------------------------------------------------------

// IndexShardConf

// required .elasticfaiss.IndexConf conf = 1;
inline bool IndexShardConf::has_conf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IndexShardConf::set_has_conf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IndexShardConf::clear_has_conf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IndexShardConf::clear_conf() {
  if (conf_ != NULL) conf_->Clear();
  clear_has_conf();
}
inline const ::elasticfaiss::IndexConf& IndexShardConf::_internal_conf() const {
  return *conf_;
}
inline const ::elasticfaiss::IndexConf& IndexShardConf::conf() const {
  const ::elasticfaiss::IndexConf* p = conf_;
  // @@protoc_insertion_point(field_get:elasticfaiss.IndexShardConf.conf)
  return p != NULL ? *p : *reinterpret_cast<const ::elasticfaiss::IndexConf*>(
      &::elasticfaiss::_IndexConf_default_instance_);
}
inline ::elasticfaiss::IndexConf* IndexShardConf::release_conf() {
  // @@protoc_insertion_point(field_release:elasticfaiss.IndexShardConf.conf)
  clear_has_conf();
  ::elasticfaiss::IndexConf* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline ::elasticfaiss::IndexConf* IndexShardConf::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) {
    auto* p = CreateMaybeMessage<::elasticfaiss::IndexConf>(GetArenaNoVirtual());
    conf_ = p;
  }
  // @@protoc_insertion_point(field_mutable:elasticfaiss.IndexShardConf.conf)
  return conf_;
}
inline void IndexShardConf::set_allocated_conf(::elasticfaiss::IndexConf* conf) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete conf_;
  }
  if (conf) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      conf = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conf, submessage_arena);
    }
    set_has_conf();
  } else {
    clear_has_conf();
  }
  conf_ = conf;
  // @@protoc_insertion_point(field_set_allocated:elasticfaiss.IndexShardConf.conf)
}

// required int32 shard_idx = 2;
inline bool IndexShardConf::has_shard_idx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IndexShardConf::set_has_shard_idx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IndexShardConf::clear_has_shard_idx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IndexShardConf::clear_shard_idx() {
  shard_idx_ = 0;
  clear_has_shard_idx();
}
inline ::google::protobuf::int32 IndexShardConf::shard_idx() const {
  // @@protoc_insertion_point(field_get:elasticfaiss.IndexShardConf.shard_idx)
  return shard_idx_;
}
inline void IndexShardConf::set_shard_idx(::google::protobuf::int32 value) {
  set_has_shard_idx();
  shard_idx_ = value;
  // @@protoc_insertion_point(field_set:elasticfaiss.IndexShardConf.shard_idx)
}

// repeated string nodes = 3;
inline int IndexShardConf::nodes_size() const {
  return nodes_.size();
}
inline void IndexShardConf::clear_nodes() {
  nodes_.Clear();
}
inline const ::std::string& IndexShardConf::nodes(int index) const {
  // @@protoc_insertion_point(field_get:elasticfaiss.IndexShardConf.nodes)
  return nodes_.Get(index);
}
inline ::std::string* IndexShardConf::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:elasticfaiss.IndexShardConf.nodes)
  return nodes_.Mutable(index);
}
inline void IndexShardConf::set_nodes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:elasticfaiss.IndexShardConf.nodes)
  nodes_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void IndexShardConf::set_nodes(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:elasticfaiss.IndexShardConf.nodes)
  nodes_.Mutable(index)->assign(std::move(value));
}
#endif
inline void IndexShardConf::set_nodes(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  nodes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:elasticfaiss.IndexShardConf.nodes)
}
inline void IndexShardConf::set_nodes(int index, const char* value, size_t size) {
  nodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:elasticfaiss.IndexShardConf.nodes)
}
inline ::std::string* IndexShardConf::add_nodes() {
  // @@protoc_insertion_point(field_add_mutable:elasticfaiss.IndexShardConf.nodes)
  return nodes_.Add();
}
inline void IndexShardConf::add_nodes(const ::std::string& value) {
  nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:elasticfaiss.IndexShardConf.nodes)
}
#if LANG_CXX11
inline void IndexShardConf::add_nodes(::std::string&& value) {
  nodes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:elasticfaiss.IndexShardConf.nodes)
}
#endif
inline void IndexShardConf::add_nodes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  nodes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:elasticfaiss.IndexShardConf.nodes)
}
inline void IndexShardConf::add_nodes(const char* value, size_t size) {
  nodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:elasticfaiss.IndexShardConf.nodes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IndexShardConf::nodes() const {
  // @@protoc_insertion_point(field_list:elasticfaiss.IndexShardConf.nodes)
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IndexShardConf::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:elasticfaiss.IndexShardConf.nodes)
  return &nodes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace elasticfaiss

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::elasticfaiss::ShardState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::elasticfaiss::ShardState>() {
  return ::elasticfaiss::ShardState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_shard_2eproto
